# A0139422J
###### /java/main/ui/HelpWindow.java
``` java
package main.ui;



import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.layout.AnchorPane;
import javafx.scene.web.WebView;
import javafx.stage.Stage;
import main.commons.util.FxViewUtil;
import main.Main;
import main.commons.core.LogsCenter;
import java.util.logging.Logger;
import javafx.fxml.FXML;

/**
 * Controller for a help page
 * "person" keyword check done
 * "addressbook" keyword check done
 * @author bey
 */
public class HelpWindow extends UiPart {

    private static final Logger logger = LogsCenter.getLogger(HelpWindow.class);
    private static final String ICON = "/images/pp.png";
    private static final String FXML = "HelpWindow.fxml";
    private static final String TITLE = "Help";

    private AnchorPane mainPane;

    private Stage dialogStage;

    public static HelpWindow load(Stage primaryStage) {
        logger.fine("Showing help page about the application.");
        HelpWindow helpWindow = UiPartLoader.loadUiPart(primaryStage, new HelpWindow());
        helpWindow.configure();
        return helpWindow;
    }
   
    @Override
    public void setNode(Node node) {
        mainPane = (AnchorPane) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    private void configure(){
        Scene scene = new Scene(mainPane);
        //Null passed as the parent stage to make it non-modal.
        dialogStage = createDialogStage(TITLE, null, scene);
        dialogStage.setMaximized(true); //TODO: set a more appropriate initial size
        setIcon(dialogStage, ICON);

        WebView browser = new WebView();
        String url  = Main.class.getResource("/html/help.html").toExternalForm();
        browser.getEngine().load(url);
        FxViewUtil.applyAnchorBoundaryParameters(browser, 0.0, 0.0, 0.0, 0.0);
        mainPane.getChildren().add(browser);
    }

    public void show() {
        dialogStage.show();
    } 
```
###### /java/main/ui/HelpWindow.java
``` java
    public void closeHelpWindow(){
    	dialogStage.close();
    }
 
}
```
###### /java/main/ui/UiPart.java
``` java
package main.ui;


import main.commons.core.EventsCenter;

import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.layout.AnchorPane;
import javafx.stage.Modality;
import javafx.stage.Stage;
import main.commons.events.BaseEvent;
import main.commons.util.AppUtil;

/**
 * Base class for UI parts. 2 abstract functions: getNode(), getFxmlPath().
 * A 'UI part' represents a distinct part of the UI. e.g. Windows, dialogs, panels, status bars, etc.
 * "person" keyword check done
 * "addressbook" keyword check done
 *@author bey
 */
public abstract class UiPart {

    /**
     * The primary stage for the UI Part.
     */
    Stage primaryStage;

    public UiPart(){

    }

    /**
     * Raises the event via {@link EventsCenter#post(BaseEvent)}
     * @param event
     */
    protected void raise(BaseEvent event){
        EventsCenter.getInstance().post(event);
    }

    /**
     * Registers the object as an event handler at the {@link EventsCenter}
     * @param handler usually {@code this}
     */
    protected void registerAsAnEventHandler(Object handler) {
        EventsCenter.getInstance().registerHandler(handler);
    }

    /**
     * Override this method to receive the main Node generated while loading the view from the .fxml file.
     * @param node
     */
    public abstract void setNode(Node node);

    /**
     * Override this method to return the name of the fxml file. e.g. {@code "MainWindow.fxml"}
     * @return
     */
    public abstract String getFxmlPath();

    public void setStage(Stage primaryStage) {
        this.primaryStage = primaryStage;
    }


    /**
     * Creates a modal dialog.
     * @param title Title of the dialog.
     * @param parentStage The owner stage of the dialog.
     * @param scene The scene that will contain the dialog.
     * @return the created dialog, not yet made visible.
     */
    protected Stage createDialogStage(String title, Stage parentStage, Scene scene) {
        Stage dialogStage = new Stage();
        dialogStage.setTitle(title);
        dialogStage.initModality(Modality.WINDOW_MODAL);
        dialogStage.initOwner(parentStage);
        dialogStage.setScene(scene);
        return dialogStage;
    }

    /**
     * Sets the given image as the icon for the primary stage of this UI Part.
     * @param iconSource e.g. {@code "/images/help_icon.png"}
     */
    protected void setIcon(String iconSource) {
        primaryStage.getIcons().add(AppUtil.getImage(iconSource));
    }

    /**
     * Sets the given image as the icon for the given stage.
     * @param stage
     * @param iconSource e.g. {@code "/images/help_icon.png"}
     */
    protected void setIcon(Stage stage, String iconSource) {
        stage.getIcons().add(AppUtil.getImage(iconSource));
    }

    /**
     * Sets the placeholder for UI parts that reside inside another UI part.
     * @param placeholder
     */
    public void setPlaceholder(AnchorPane placeholder) {
        //Do nothing by default.
    }

    public Stage getPrimaryStage() {
        return primaryStage;
    }
}
```
###### /java/main/ui/StatusBarFooter.java
``` java
package main.ui;

import javafx.fxml.FXML;
import javafx.scene.Node;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.GridPane;
import javafx.stage.Stage;
import main.commons.events.model.TaskTrackerChangedEvent;
import main.commons.util.FxViewUtil;

import main.commons.core.LogsCenter;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Date;
import java.util.logging.Logger;

import org.controlsfx.control.StatusBar;

import com.google.common.eventbus.Subscribe;

/**
 * A ui for the status bar that is displayed at the footer of the application.
 * "person" keyword check done
 * "addressbook" keyword check done
 * @param AnchorPane saveLocStatusBarPane
 * @param AnchorPane syncStatusBarPane
 * @author bey
 */
public class StatusBarFooter extends UiPart {
    private static final Logger logger = LogsCenter.getLogger(StatusBarFooter.class);
    private static StatusBarFooter statusBarFooter;
    private StatusBar syncStatus;
    private StatusBar saveLocationStatus;

    private GridPane mainPane;

    @FXML
    private AnchorPane saveLocStatusBarPane;

    @FXML
    private AnchorPane syncStatusBarPane;

    private AnchorPane placeHolder;

    private static final String FXML = "StatusBarFooter.fxml";
    
    private static String saveLocation;

    public static StatusBarFooter load(Stage stage, AnchorPane placeHolder, String saveLocation) {
        statusBarFooter = UiPartLoader.loadUiPart(stage, placeHolder, new StatusBarFooter());
        statusBarFooter.configure(saveLocation);
        return statusBarFooter;
    }

    public void configure(String saveLocation) {
        addMainPane();
        addSyncStatus();
        setSyncStatus(getCurrentLocalDateTime());
        addSaveLocation();
        setSaveLocation("./" + saveLocation);
        registerAsAnEventHandler(this);
    }

    private String getCurrentLocalDateTime() {
		DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd-MM-yyyy HH:mm");
		LocalDateTime dateTime = LocalDateTime.now();
		String formattedDateTime = dateTime.format(formatter);
		return formattedDateTime;
	}

	private void addMainPane() {
        FxViewUtil.applyAnchorBoundaryParameters(mainPane, 0.0, 0.0, 0.0, 0.0);
        placeHolder.getChildren().add(mainPane);
    }

    private void setSaveLocation(String location) {
        this.saveLocation = location;
        String tidyPath = tidyNewSavePath(location);
        this.saveLocationStatus.setText(tidyPath);
    }
    
    private String tidyNewSavePath(String command) {
        command = command.replaceAll("storage", "");
        command = command.trim();
        return command;
         
     }
    
    public static void updateSaveLocation(String newSaveLocation){
        statusBarFooter.setSaveLocation(newSaveLocation);
    }
    
    private void addSaveLocation() {
        this.saveLocationStatus = new StatusBar();
        FxViewUtil.applyAnchorBoundaryParameters(saveLocationStatus, 0.0, 0.0, 0.0, 0.0);
        saveLocStatusBarPane.getChildren().add(saveLocationStatus);
        saveLocStatusBarPane.setMinWidth(150);
    }

    private void setSyncStatus(String status) {
        this.syncStatus.setText(status);
    }

    private void addSyncStatus() {
        this.syncStatus = new StatusBar();
        FxViewUtil.applyAnchorBoundaryParameters(syncStatus, 0.0, 0.0, 0.0, 0.0);
        syncStatusBarPane.getChildren().add(syncStatus);
    }

    @Override
    public void setNode(Node node) {
        mainPane = (GridPane) node;
    }

    @Override
    public void setPlaceholder(AnchorPane placeholder) {
        this.placeHolder = placeholder;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    @Subscribe
    public void handleTaskTrackerChangedEvent(TaskTrackerChangedEvent abce) {
        String lastUpdated = (new Date()).toString();
        logger.info(LogsCenter.getEventHandlingLogMessage(abce, "Setting last updated status to " + lastUpdated));
        setSyncStatus("Last Updated: " + lastUpdated);
    }
    
    public void changeStyle(String colorChange){
    	mainPane.setStyle(colorChange);
    	saveLocStatusBarPane.setStyle(colorChange);
    	syncStatusBarPane.setStyle(colorChange);
    	placeHolder.setStyle(colorChange);
    }
}
```
###### /java/main/ui/TaskListPanel.java
``` java
package main.ui;

import javafx.application.Platform;
import javafx.collections.ObservableList;
import javafx.fxml.FXML;
import javafx.scene.Node;
import javafx.scene.control.ListCell;
import javafx.scene.control.ListView;
import javafx.scene.control.SplitPane;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;
import main.commons.core.LogsCenter;
import main.commons.events.ui.TaskPanelSelectionChangedEvent;
import main.model.task.ReadOnlyTask;

import java.util.logging.Logger;

/**
 * Panel containing the list of tasks. "person" keyword check done "addressbook"
 * keyword check done
 * 
 * @param ListView<ReadOnlyTask>
 *            taskListView
 * @author bey
 */
public class TaskListPanel extends UiPart {
	private final Logger logger = LogsCenter.getLogger(TaskListPanel.class);
	private static final String FXML = "TaskListPanel.fxml";
	private VBox panel;
	private AnchorPane placeHolderPane;
	private static int currentMaxListSize;

	@FXML
	private ListView<ReadOnlyTask> taskListView;

	public TaskListPanel() {
		super();
	}

	@Override
	public void setNode(Node node) {
		panel = (VBox) node;
	}

	@Override
	public String getFxmlPath() {
		return FXML;
	}

	@Override
	public void setPlaceholder(AnchorPane pane) {
		this.placeHolderPane = pane;
	}

	public static TaskListPanel load(Stage primaryStage, AnchorPane taskListPlaceholder,
			ObservableList<ReadOnlyTask> taskList) {
		TaskListPanel taskListPanel = UiPartLoader.loadUiPart(primaryStage, taskListPlaceholder, new TaskListPanel());
		taskListPanel.configure(taskList);
		return taskListPanel;
	}

	private void configure(ObservableList<ReadOnlyTask> taskList) {
		setConnections(taskList);
		addToPlaceholder();
	}

	private void setConnections(ObservableList<ReadOnlyTask> taskList) {
		taskListView.setItems(taskList);
		taskListView.setCellFactory(listView -> new TaskListViewCell());
		setEventHandlerForSelectionChangeEvent();
	}

	private void addToPlaceholder() {
		SplitPane.setResizableWithParent(placeHolderPane, true);
		placeHolderPane.getChildren().add(panel);
	}

	private void setEventHandlerForSelectionChangeEvent() {
		taskListView.getSelectionModel().selectedItemProperty().addListener((observable, oldValue, newValue) -> {
			if (newValue != null) {
				logger.fine("Selection in task list panel changed to : '" + newValue + "'");
				raise(new TaskPanelSelectionChangedEvent(newValue));
			}
		});
	}

	public void scrollTo(int index) {
		Platform.runLater(() -> {
			taskListView.scrollTo(index);
			taskListView.getSelectionModel().clearAndSelect(index);
		});
	}

	class TaskListViewCell extends ListCell<ReadOnlyTask> {

		public TaskListViewCell() {}

		@Override
		protected void updateItem(ReadOnlyTask task, boolean empty) {
			super.updateItem(task, empty);

			if (empty || task == null) {
				setGraphic(null);
				setText(null);
			} else {
				setGraphic(TaskCard.load(task, getIndex() + 1).getLayout());
			}
		}
	}

	public ListView<ReadOnlyTask> getTaskListView() {
		return taskListView;
	}
}
```
###### /java/main/ui/ListStatistics.java
``` java
package main.ui;

import javafx.scene.Node;
import javafx.scene.control.Label;
import javafx.scene.image.ImageView;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;
import main.commons.util.AppUtil;
import main.commons.util.FxViewUtil;
import main.logic.Logic;
import main.model.Model;

import java.util.ArrayList;

import javafx.beans.property.SimpleStringProperty;
import javafx.beans.property.StringProperty;
import javafx.fxml.FXML;
import javafx.geometry.Insets;

public class ListStatistics extends UiPart {

	private static final String FXML = "ListStatistics.fxml";

	@FXML
	private Label floatingtasks;

	@FXML
	private Label alltasks;

	@FXML
	private Label eventtasks;

	@FXML
	private Label tomorrowtasks;

	@FXML
	private Label deadlinetasks;

	@FXML
	private Label todaytasks;

	ArrayList<Label> labelList = new ArrayList<Label>(6);
	
	@FXML
	private ImageView image;

	private static final String TODAY_TASK_MESSAGE = " <-: Tasks Due Today ";
	private static final String TOMORROW_TASK_MESSAGE = " <-: Tasks Due Tomorrow ";
	private static final String EVENT_TASK_MESSAGE = " <-: Events ";
	private static final String DEADLINE_TASK_MESSAGE = " <-: Deadlines ";
	private static final String FLOATING_TASK_MESSAGE = " <-: Floating ";
	private static final String ALL_TASK_MESSAGE = " <-: Total ";
	
	private Model model;

	private static Logic logic;

	private AnchorPane placeHolder;

	private static VBox mainPane;

	private static ListStatistics listDisplay;

	private StringProperty todaytaskNo = new SimpleStringProperty("");
	private StringProperty tomorrowtaskNo = new SimpleStringProperty("");
	private StringProperty eventtaskNo = new SimpleStringProperty("");
	private StringProperty deadlinetaskNo = new SimpleStringProperty("");
	private StringProperty floatingtaskNo = new SimpleStringProperty("");
	private StringProperty alltaskNo = new SimpleStringProperty("");
	
	ArrayList<StringProperty> labelContent = new ArrayList<StringProperty>(6);
	
	public static ListStatistics load(Stage primaryStage, AnchorPane placeHolder, Logic logic) {
		listDisplay = UiPartLoader.loadUiPart(primaryStage, placeHolder, new ListStatistics());
		ListStatistics.logic = logic;
		listDisplay.configure();
		return listDisplay;
	}

	public ListStatistics() {
		todaytasks = new Label();
		tomorrowtasks = new Label();
		eventtasks = new Label();
		deadlinetasks = new Label();
		floatingtasks = new Label();
		alltasks = new Label();
	}
	
	public void configure() {
		mainPane = new VBox();
		convertToLabelList();
		bindingAllStringProperty();
		initializeStringProperty();
		setListIcon();
		mainPane.getChildren().addAll(image, todaytasks, tomorrowtasks, eventtasks, deadlinetasks, floatingtasks,
				alltasks);
		mainPane.setSpacing(30.0);
		mainPane.setPadding(new Insets(30.0, 0.0, 30.0, 30.0));
		placeHolder.getChildren().add(mainPane);
		FxViewUtil.applyAnchorBoundaryParameters(mainPane, 0.0, 0.0, 0.0, 0.0);
		placeHolder.setMaxWidth(400);
	}
	/**
	 * Adds all six labels in a Arraylist for easy processing in later stages
	 */
	private void convertToLabelList() {
		labelList.add(todaytasks);
		labelList.add(tomorrowtasks);
		labelList.add(eventtasks);
		labelList.add(deadlinetasks);
		labelList.add(floatingtasks);
		labelList.add(alltasks);
	}

	private void bindingAllStringProperty() {
		todaytasks.textProperty().bind(todaytaskNo);
		tomorrowtasks.textProperty().bind(tomorrowtaskNo);
		eventtasks.textProperty().bind(eventtaskNo);
		deadlinetasks.textProperty().bind(deadlinetaskNo);
		floatingtasks.textProperty().bind(floatingtaskNo);
		alltasks.textProperty().bind(alltaskNo);
	}

	private void setListIcon() {
		image = new ImageView(AppUtil.getImage("/images/statistics.png"));
	}

	private void initializeStringProperty() {
		todaytaskNo.setValue(logic.getNumToday() + TODAY_TASK_MESSAGE);
		tomorrowtaskNo.setValue(logic.getNumTmr() + TOMORROW_TASK_MESSAGE);
		eventtaskNo.setValue(logic.getNumEvent() + EVENT_TASK_MESSAGE);
		deadlinetaskNo.setValue(logic.getNumDeadline() + DEADLINE_TASK_MESSAGE);
		floatingtaskNo.setValue(logic.getNumFloating() + FLOATING_TASK_MESSAGE);
		alltaskNo.setValue(logic.getTotalNum() + ALL_TASK_MESSAGE);
	}
	
	public static void updateAll(String command){
		updateListImage(command);
		updateStatistics();		
	}
	
	public static void updateStatistics() {
		listDisplay.getTodayTaskNo().setValue(logic.getNumToday() + TODAY_TASK_MESSAGE);
		listDisplay.getTomorrowTaskNo().setValue(logic.getNumTmr() + TOMORROW_TASK_MESSAGE);
		listDisplay.getEventTaskNo().setValue(logic.getNumEvent() + EVENT_TASK_MESSAGE);
		listDisplay.getDeadlineTaskNo().setValue(logic.getNumDeadline() + DEADLINE_TASK_MESSAGE);
		listDisplay.getFloatingTaskNo().setValue(logic.getNumFloating() + FLOATING_TASK_MESSAGE);
		listDisplay.getAllTaskNo().setValue(logic.getTotalNum() + ALL_TASK_MESSAGE);

	}

	public static void updateListImage(String command) {
		if (command.matches("[a-zA-Z ]*\\d+.*"))
			listDisplay.getImage().setImage(AppUtil.getImage("/images/calendar.png"));
		else if (command.contains("events"))
			listDisplay.getImage().setImage(AppUtil.getImage("/images/events.png"));
		else if (command.contains("deadlines"))
			listDisplay.getImage().setImage(AppUtil.getImage("/images/deadlines.png"));
		else if (command.contains("floating"))
			listDisplay.getImage().setImage(AppUtil.getImage("/images/floating.png"));
		else if (command.contains("high"))
            listDisplay.getImage().setImage(AppUtil.getImage("/images/high.png"));
		else if (command.contains("low"))
            listDisplay.getImage().setImage(AppUtil.getImage("/images/low.png"));
		else if (command.contains("normal"))
            listDisplay.getImage().setImage(AppUtil.getImage("/images/normal.png"));
		else 
			listDisplay.getImage().setImage(AppUtil.getImage("/images/statistics.png"));
	}

	public StringProperty getTodayTaskNo() {
		return todaytaskNo;
	}

	public StringProperty getTomorrowTaskNo() {
		return tomorrowtaskNo;
	}

	public StringProperty getEventTaskNo() {
		return eventtaskNo;
	}

	public StringProperty getDeadlineTaskNo() {
		return deadlinetaskNo;
	}

	public StringProperty getFloatingTaskNo() {
		return floatingtaskNo;
	}

	public Label getAllTasksLabel() {
		return alltasks;
	}

	public StringProperty getAllTaskNo() {
		return alltaskNo;
	}

	public ImageView getImage() {
		return image;
	}

	@Override
	public void setNode(Node node) {
		mainPane = (VBox) node;
	}

	@Override
	public void setPlaceholder(AnchorPane placeholder) {
		this.placeHolder = placeholder;
	}

	@Override
	public String getFxmlPath() {
		return FXML;
	}
}
```
###### /java/main/ui/UiManager.java
``` java
package main.ui;

import com.google.common.eventbus.Subscribe;
import javafx.application.Platform;
import javafx.scene.control.Alert;
import javafx.scene.control.Alert.AlertType;
import javafx.scene.image.Image;
import javafx.stage.Stage;
import main.Main;
import main.logic.Logic;
import main.model.UserPrefs;
import main.commons.core.ComponentManager;
import main.commons.core.Config;
import main.commons.core.LogsCenter;
import main.commons.events.storage.DataSavingExceptionEvent;
import main.commons.events.ui.JumpToListRequestEvent;
import main.commons.events.ui.ShowHelpRequestEvent;
import main.commons.events.ui.TaskPanelSelectionChangedEvent;
import main.commons.util.StringUtil;
import java.util.logging.Logger;

/**
 * The manager of the UI component.
 * "person" keyword check done
 * "addressbook" keyword check done
 * @author bey
 */
public class UiManager extends ComponentManager implements Ui {
    private static final Logger logger = LogsCenter.getLogger(UiManager.class);
    private static final String ICON_APPLICATION = "/images/pp.png";

    private Logic logic;
    private Config config;
    private UserPrefs prefs;
    private MainWindow mainWindow;

    public UiManager(Logic logic, Config config, UserPrefs prefs) {
        super();
        this.logic = logic;
        this.config = config;
        this.prefs = prefs;
    }

    @Override
    public void start(Stage primaryStage) {
        logger.info("Starting UI...");
        primaryStage.setTitle(config.getAppTitle());

        //Set the application icon.
        primaryStage.getIcons().add(getImage(ICON_APPLICATION));

        try {
            mainWindow = MainWindow.load(primaryStage, config, prefs, logic);
            mainWindow.show(); //This should be called before creating other UI parts
            mainWindow.fillInnerParts();

        } catch (Throwable e) {
            logger.severe(StringUtil.getDetails(e));
            showFatalErrorDialogAndShutdown("Fatal error during initializing", e);
        }
    }

    @Override
    public void stop() {
        prefs.updateLastUsedGuiSetting(mainWindow.getCurrentGuiSetting());
        mainWindow.hide();
        mainWindow.closeHelpWindow();
    }

    private void showFileOperationAlertAndWait(String description, String details, Throwable cause) {
        final String content = details + ":\n" + cause.toString();
        showAlertDialogAndWait(AlertType.ERROR, "File Op Error", description, content);
    }

    private Image getImage(String imagePath) {
        return new Image(Main.class.getResourceAsStream(imagePath));
    }

    void showAlertDialogAndWait(Alert.AlertType type, String title, String headerText, String contentText) {
        showAlertDialogAndWait(mainWindow.getPrimaryStage(), type, title, headerText, contentText);
    }

    private static void showAlertDialogAndWait(Stage owner, AlertType type, String title, String headerText,
                                               String contentText) {
        final Alert alert = new Alert(type);
        alert.getDialogPane().getStylesheets().add("view/DarkTheme.css");
        alert.initOwner(owner);
        alert.setTitle(title);
        alert.setHeaderText(headerText);
        alert.setContentText(contentText);

        alert.showAndWait();
    }

    private void showFatalErrorDialogAndShutdown(String title, Throwable e) {
        logger.severe(title + " " + e.getMessage() + StringUtil.getDetails(e));
        showAlertDialogAndWait(Alert.AlertType.ERROR, title, e.getMessage(), e.toString());
        Platform.exit();
        System.exit(1);
    }

    //==================== Event Handling Code =================================================================

    @Subscribe
    private void handleDataSavingExceptionEvent(DataSavingExceptionEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        showFileOperationAlertAndWait("Could not save data", "Could not save data to file", event.exception);
    }

    @Subscribe
    private void handleShowHelpEvent(ShowHelpRequestEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        mainWindow.handleHelp();
    }

    @Subscribe
    private void handleJumpToListRequestEvent(JumpToListRequestEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        mainWindow.getTaskListPanel().scrollTo(event.targetIndex);
    }

    @Subscribe
    private void handleTaskPanelSelectionChangedEvent(TaskPanelSelectionChangedEvent event){
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
//        mainWindow.loadTaskPage(event.getNewSelection());
    }

}
```
###### /java/main/ui/Ui.java
``` java
package main.ui;

import javafx.stage.Stage;

/**
 * API of Ui component
 * All Ui classes which implements this interface must have a start and stop function
 * @author bey
 */
public interface Ui {

    /** Starts the UI (and the App).  */
    void start(Stage primaryStage);

    /** Stops the UI. */
    void stop();

}
```
###### /java/main/ui/TaskCard.java
``` java
package main.ui;


import javafx.beans.property.ReadOnlyDoubleProperty;
import javafx.fxml.FXML;
import javafx.scene.Node;
import javafx.scene.control.Label;
import javafx.scene.layout.HBox;
import javafx.scene.paint.Color;
import javafx.scene.shape.Rectangle;
import main.model.task.PriorityType;
import main.model.task.ReadOnlyTask;
import main.model.task.TaskType;

/**
 * Display individual panels within TaskListPanel with the details of eacch specific task
 * "person" keyword check done
 * "addressbook" keyword check done
 * @param HBox cardPane
 * @param Label id
 * @param Label message
 * @param Label date
 * @param Rectangle priorityTab
 * @author bey
 *
 */
public class TaskCard extends UiPart{

    private static final String FXML = "TaskListCard.fxml";

    @FXML
    private HBox cardPane;
    @FXML
    private Label id;
    @FXML
    private Label message;
    @FXML
    private Label deadline;

    @FXML
    private Label recurring;
    
    @FXML
    private Rectangle priorityTab;

    private ReadOnlyTask task;
    private int displayedIndex;
    
    public TaskCard(){

    }

    public static TaskCard load(ReadOnlyTask task, int displayedIndex){
        TaskCard card = new TaskCard();
        card.task = task;
        card.displayedIndex = displayedIndex;
        return UiPartLoader.loadUiPart(card);
    }

    @FXML
    public void initialize() {
     
        configureLayout();     
        setTaskCardText();
        setPriorityTabColour();
        
    }
    
    private void setTaskCardText() {
        
        message.setText(task.getMessage());
        message.setWrapText(true);
        
        id.setText(displayedIndex + ". ");
        
        if (task.getType() == TaskType.EVENT)
        	deadline.setText("Start: "+ task.getStartTimeString() + "\nEnd: "+ task.getEndTimeString());
        else if (task.getType() == TaskType.DEADLINE)
            deadline.setText("Deadline: "+ task.getDeadlineString());
        else
            deadline.setText("");
        
        if (task.getIsRecurring())
            recurring.setText("Weekly");
        else
            recurring.setText("");
    }
    
    private void setPriorityTabColour() {
        
        if (task.getPriority() == PriorityType.HIGH){
            priorityTab.setFill(Color.RED);
            cardPane.setStyle("-fx-background-color: #ff6666;");
        }
        else if (task.getPriority() == PriorityType.LOW){
            priorityTab.setFill(Color.YELLOWGREEN);
            cardPane.setStyle("-fx-background-color: #ffffb3;");
		}
        else{
            priorityTab.setFill(Color.rgb(255, 117, 26));
            cardPane.setStyle("-fx-background-color: #ffa366;");
       }
		
        if (task.isOverdue()) {
            priorityTab.setFill(Color.BLACK);           
        }		

        priorityTab.setStroke(Color.TRANSPARENT);
    }
    
    private void configureLayout() {
    	
//        cardPane.setSpacing(18.0);
//        deadline.setMinWidth(300);
//        cardPane.setMinWidth(450);

    }

    public HBox getLayout() {
        return cardPane;
    }

    @Override
    public void setNode(Node node) {
        cardPane = (HBox)node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }
}
```
###### /java/main/ui/CommandBox.java
``` java
package main.ui;

import com.google.common.eventbus.Subscribe;

import javafx.fxml.FXML;
import javafx.scene.Node;
import javafx.scene.control.SplitPane;
import javafx.scene.control.TextField;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.layout.AnchorPane;
import javafx.stage.Stage;
import main.commons.events.ui.AutoCompleteEvent;
import main.commons.events.ui.IncorrectCommandAttemptedEvent;
import main.commons.events.ui.KeyPressEvent;
import main.commons.events.ui.TabPressEvent;
import main.commons.util.FxViewUtil;
import main.logic.Logic;
import main.logic.command.CommandResult;
import main.commons.core.EventsCenter;
import main.commons.core.LogsCenter;

import java.util.ArrayList;
import java.util.logging.Logger;

/**
 * Contains the main input component which would interact with Logic most.
 * "person" key check done "addressbook" keyword check done
 * 
 * @param FXML
 *            TextField commandTextField
 * @param FXML
 *            CommandResult mostRecentResult
```
###### /java/main/ui/CommandBox.java
``` java
 */

public class CommandBox extends UiPart {
    private final Logger logger = LogsCenter.getLogger(CommandBox.class);
    private static final String FXML = "CommandBox.fxml";

    private AnchorPane placeHolderPane;
    private AnchorPane commandPane;
    private ResultDisplay resultDisplay;
    String previousCommandTest;

    private Logic logic;
    private static ArrayList<String> commandHistory = new ArrayList<String>();
    private static int historyPointer = 0;

    @FXML
    private TextField commandTextField;
    private CommandResult mostRecentResult;

    public static CommandBox load(Stage primaryStage, AnchorPane commandBoxPlaceholder, ResultDisplay resultDisplay,
            Logic logic) {
        CommandBox commandBox = UiPartLoader.loadUiPart(primaryStage, commandBoxPlaceholder, new CommandBox());
        commandBox.configure(resultDisplay, logic);
        commandBox.addToPlaceholder();
        commandBox.handleAllEvents();
        return commandBox;
    }

    public void configure(ResultDisplay resultDisplay, Logic logic) {
        this.resultDisplay = resultDisplay;
        this.logic = logic;
        registerAsAnEventHandler(this);
    }

    private void addToPlaceholder() {
        SplitPane.setResizableWithParent(placeHolderPane, false);
        placeHolderPane.getChildren().add(commandTextField);
        FxViewUtil.applyAnchorBoundaryParameters(commandPane, 0.0, 0.0, 0.0, 0.0);
        FxViewUtil.applyAnchorBoundaryParameters(commandTextField, 0.0, 0.0, 0.0, 0.0);
        placeHolderPane.setMaxHeight(50);
    }

    @Override
    public void setNode(Node node) {
        commandPane = (AnchorPane) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    @Override
    public void setPlaceholder(AnchorPane pane) {
        this.placeHolderPane = pane;
    }

    @FXML
    private void handleCommandInputChanged() {
        resultDisplay.clearResultDisplay();
        // Take a copy of the command text
        previousCommandTest = commandTextField.getText();
        CommandBox.getHistory().add(previousCommandTest);
        /*
         * We assume the command is correct. If it is incorrect, the command box
         * will be changed accordingly in the event handling code {@link
         * #handleIncorrectCommandAttempted}
         */
        setStyleToIndicateCorrectCommand();
        mostRecentResult = logic.execute(previousCommandTest);
        String resultMessage = mostRecentResult.feedbackToUser;
        ListStatistics.updateAll(resultMessage);
        CommandBox.resetHistoryPointer();
        
        if (saveLocationIsChanged(previousCommandTest, resultMessage)){
            StatusBarFooter.updateSaveLocation(previousCommandTest);
        }
        
        resultDisplay.postMessage(resultMessage);
        logger.info("Result: " + resultMessage);
    }

    private boolean saveLocationIsChanged(String command, String resultMessage) {   
        return ((command.contains("storage")) && (!resultMessage.contains("XML file not found at the specified location."))&& (!command.contains("invalid")));
    }

    private static void resetHistoryPointer() {
        historyPointer = commandHistory.size();

    }

    /**
     * Sets the command box style to indicate a correct command.
     */
    private void setStyleToIndicateCorrectCommand() {
        commandTextField.getStyleClass().remove("error");
        commandTextField.setText("");
    }

    @Subscribe
    private void handleIncorrectCommandAttempted(IncorrectCommandAttemptedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event, "Invalid command: " + previousCommandTest));
        // setStyleToIndicateIncorrectCommand();
        commandTextField.setText("");
    }

    /**
     * Sets the command box style to indicate an error
     */
    private void setStyleToIndicateIncorrectCommand() {
        commandTextField.getStyleClass().add("error");
    }

    public TextField getCommandBoxTextField() {
        return commandTextField;
    }

    public void handleAllEvents() {
        handleUpEvent();
        handleDownEvent();
        handleTabEvent();
    }

    private void handleUpEvent() {

        commandTextField.addEventFilter(KeyEvent.KEY_PRESSED, (KeyEvent event) -> {
            if (event.getCode() == KeyCode.UP) {
                if (historyPointer > 0) {

                    --historyPointer;
                    System.out.println(historyPointer + " " + CommandBox.getHistory().get(historyPointer));
                } else
                    historyPointer = 0;
                commandTextField.setText(CommandBox.getHistory().get(historyPointer));
                event.consume();

            }
        });
    }

    private void handleDownEvent() {
        commandTextField.addEventFilter(KeyEvent.KEY_PRESSED, (KeyEvent event) -> {
            if (event.getCode() == KeyCode.DOWN) {
                if (historyPointer < CommandBox.getHistory().size() - 1) {

                    ++historyPointer;
                    System.out.println(historyPointer + " " + CommandBox.getHistory().get(historyPointer));
                } else
                    historyPointer = (CommandBox.getHistory().size()) - 1;
                commandTextField.setText(CommandBox.getHistory().get(historyPointer));
                event.consume();
            }
        });
    }

    public static ArrayList<String> getHistory() {
        return commandHistory;
    }

```
###### /java/main/ui/MainWindow.java
``` java
package main.ui;

import main.commons.core.Config;
import java.util.List;
import java.util.Optional;

import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.ListView;
import javafx.scene.control.MenuItem;
import javafx.scene.control.SplitPane;
import javafx.scene.control.TextArea;
import javafx.scene.control.TextField;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyCodeCombination;
import javafx.scene.input.KeyCombination;
import javafx.scene.input.KeyEvent;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;
import javafx.stage.StageStyle;
import main.commons.core.Config;
import main.commons.core.GuiSettings;
import main.commons.events.ui.ExitAppRequestEvent;
import main.commons.util.FxViewUtil;
import main.logic.Logic;
import main.model.UserPrefs;
import main.model.task.ReadOnlyTask;

/**
 * Instantiates all the individual components for the Gui and interacts with
 * UiManager - CommandBox, HelpWindow, StatusBarFooter, TaskCard, TaskListPanel
 * "person" keyword check done "addressbook" keyword check done
 * 
 * @param AnchorPane
 *            commandBoxPlaceholder
 * @param MenuItem
 *            helpMenuItem
 * @param AnchorPane
 *            taskListPanelPlaceholder
 * @param AnchorPane
 *            resultDisplayPlaceholder
 * @param AnchorPane
 *            statusbarPlaceholder
 * @author bey
 */

public class MainWindow extends UiPart {

	private static final String ICON = "/images/pp.png";
	private static final String FXML = "MainWindow.fxml";
	public static final int MIN_HEIGHT = 900;
	public static final int MIN_WIDTH = 1100;

	private Logic logic;

	// Independent Ui parts residing in this Ui container
	private TaskListPanel taskListPanel;
	private ResultDisplay resultDisplay;
	private StatusBarFooter statusBarFooter;
	private CommandBox commandBox;
	private ListStatistics listStatistics;
	private HelpWindow helpWindow;
	private Config config;
	private UserPrefs userPrefs;

	// Handles to elements of this Ui container
	private VBox rootLayout;
	private Scene scene;

	private String taskTrackerName;

	@FXML
	private SplitPane splitpane;

	@FXML
	private AnchorPane commandBoxPlaceholder;

	@FXML
	private AnchorPane taskListPanelPlaceholder;

	@FXML
	private AnchorPane resultDisplayPlaceholder;

	@FXML
	private AnchorPane statusbarPlaceholder;

	@FXML
	private AnchorPane listStatisticsPlaceholder;
	
//	.spiltpane{-fx-background-color: derive(#ff6666, 20%);}
//	.spiltpane{-fx-background-color: derive(#ffffb3, 20%);}
//	.spiltpane{-fx-background-color: derive(#ffa366, 20%);}
	public static final KeyCodeCombination KEY_MINMAX = new KeyCodeCombination(KeyCode.M, KeyCodeCombination.ALT_DOWN);
	public static final String[] colorWheel = {"-fx-background-color: derive(#008000, 20%);", "-fx-background-color: derive(#006080, 20%);", "-fx-background-color: derive(#b34700, 20%);"};
	private static int taskPointer = 0;
	private static int colorPointer = 7;

	public MainWindow() {
		super();
	}

	@Override
	public void setNode(Node node) {
		rootLayout = (VBox) node;
	}

	@Override
	public String getFxmlPath() {
		return FXML;
	}

	public static MainWindow load(Stage primaryStage, Config config, UserPrefs prefs, Logic logic) {

		MainWindow mainWindow = UiPartLoader.loadUiPart(primaryStage, new MainWindow());
		mainWindow.configure(config.getAppTitle(), config.getTaskTrackerName(), config, prefs, logic);
		return mainWindow;
	}

	private void configure(String appTitle, String taskTrackerName, Config config, UserPrefs prefs, Logic logic) {

		// Set dependencies
		this.logic = logic;
		this.taskTrackerName = taskTrackerName;
		this.config = config;
		this.userPrefs = prefs;
		MainWindow.colorPointer = userPrefs.getColourPointer();

		// Configure the UI
		setTitle(appTitle);
		setIcon(ICON);
		setWindowMinSize();
		setWindowDefaultSize(prefs);
		scene = new Scene(rootLayout);
		primaryStage.setScene(scene);
		
		setWindowStyle();
		// setAccelerators();
	}

	// private void setAccelerators() {
	// helpMenuItem.setAccelerator(KeyCombination.valueOf("F1"));
	// }

	void fillInnerParts() {
		taskListPanel = TaskListPanel.load(primaryStage, getTaskListPlaceholder(), logic.getFilteredTaskList());
		resultDisplay = ResultDisplay.load(primaryStage, getResultDisplayPlaceholder());
		statusBarFooter = StatusBarFooter.load(primaryStage, getStatusbarPlaceholder(),
				config.getTaskTrackerFilePath());
		commandBox = CommandBox.load(primaryStage, getCommandBoxPlaceholder(), resultDisplay, logic);
		listStatistics = ListStatistics.load(primaryStage, getListStatisticsPlaceholder(), logic);
		setInitialInputFocus();
		handleAllEvents();
		FxViewUtil.applyAnchorBoundaryParameters(rootLayout, 0.0, 0.0, 0.0, 0.0);
		splitpane.maxWidthProperty().multiply(0.5);
	}

	@FXML
	private void setInitialInputFocus() {
		commandBox.getCommandBoxTextField().requestFocus();
	}

	private AnchorPane getCommandBoxPlaceholder() {
		return commandBoxPlaceholder;
	}

	private AnchorPane getStatusbarPlaceholder() {
		return statusbarPlaceholder;
	}

	private AnchorPane getResultDisplayPlaceholder() {
		return resultDisplayPlaceholder;
	}

	public AnchorPane getTaskListPlaceholder() {
		return taskListPanelPlaceholder;
	}

	public AnchorPane getListStatisticsPlaceholder() {
		return listStatisticsPlaceholder;
	}

	public void hide() {
		primaryStage.hide();
	}

	private void setTitle(String appTitle) {
		primaryStage.setTitle(appTitle);
	}

	/**
	 * Sets the default size based on user preferences.
	 */
	protected void setWindowDefaultSize(UserPrefs prefs) {
		primaryStage.setHeight(prefs.getGuiSettings().getWindowHeight());
		primaryStage.setWidth(prefs.getGuiSettings().getWindowWidth());
		if (prefs.getGuiSettings().getWindowCoordinates() != null) {
			primaryStage.setX(prefs.getGuiSettings().getWindowCoordinates().getX());
			primaryStage.setY(prefs.getGuiSettings().getWindowCoordinates().getY());
		}
	}

	private void setWindowMinSize() {
		 primaryStage.setMinHeight(MIN_HEIGHT);
		 primaryStage.setMinWidth(MIN_WIDTH);
//		 primaryStage.setMaximized(true);
	}

	/**
	 * Returns the current size and the position of the main Window.
	 */
	public GuiSettings getCurrentGuiSetting() {
		return new GuiSettings(primaryStage.getWidth(), primaryStage.getHeight(), (int) primaryStage.getX(),
				(int) primaryStage.getY());
	}

	public void handleHelp() {
		helpWindow = HelpWindow.load(primaryStage);
		helpWindow.show();
	}

	public void closeHelpWindow() {
		if (helpWindow != null)
			helpWindow.closeHelpWindow();
	}

	public void show() {
		primaryStage.show();
	}

	/**
	 * Closes the application.
	 */
	@FXML
	private void handleExit() {
		raise(new ExitAppRequestEvent());
	}

	public TaskListPanel getTaskListPanel() {
		return this.taskListPanel;
	}

	public void handleAllEvents() {
		handleMinimizeWindow();
	    handleChangeColourTheme();
		handleTaskListScrolling();
	}

	private void handleChangeColourTheme() {
	    handleF1Event();
	    handleF2Event();
    }
	
	private void handleMinimizeWindow() {
        rootLayout.addEventFilter(KeyEvent.KEY_PRESSED, (KeyEvent event) -> {
            if (event.getCode() == KeyCode.ESCAPE) {
                primaryStage.setIconified(true);
            }
        }); 
    }
	
    private void handleF1Event() {
        rootLayout.addEventFilter(KeyEvent.KEY_PRESSED, (KeyEvent event) -> {
            if (event.getCode() == KeyCode.F1) {
                if ((colorPointer + 1) > 7)
                    colorPointer = 0;
                else {
                    colorPointer = colorPointer + 1;
                    
                }
                setWindowStyle();
                userPrefs.updateColourPointer(MainWindow.colorPointer);
            }
        }); 
    }
    
    private void handleF2Event() {
        rootLayout.addEventFilter(KeyEvent.KEY_PRESSED, (KeyEvent event) -> {
            if (event.getCode() == KeyCode.F2) {
                if ((colorPointer - 1) < 0)
                    colorPointer = 7;
                else {
                    colorPointer = colorPointer - 1;
                }
                setWindowStyle();
                userPrefs.updateColourPointer(MainWindow.colorPointer);
            }
        }); 
    }
    
    private void setWindowStyle(){
    	rootLayout.getStylesheets().clear();
    	switch(colorPointer){
    		case 0:	rootLayout.getStylesheets().add(getClass().getResource("/css/RedTheme.css").toExternalForm()); break;
    		
    		case 1:	rootLayout.getStylesheets().add(getClass().getResource("/css/OrangeTheme.css").toExternalForm()); break;
    		
    		case 2:	rootLayout.getStylesheets().add(getClass().getResource("/css/YellowTheme.css").toExternalForm()); break;
    		
    		case 3:	rootLayout.getStylesheets().add(getClass().getResource("/css/GreenTheme.css").toExternalForm()); break;
    		
    		case 4:	rootLayout.getStylesheets().add(getClass().getResource("/css/BlueTheme.css").toExternalForm()); break;
    		
    		case 5:	rootLayout.getStylesheets().add(getClass().getResource("/css/IndigoTheme.css").toExternalForm()); break;
    		
    		case 6:	rootLayout.getStylesheets().add(getClass().getResource("/css/VioletTheme.css").toExternalForm()); break;
    		
    		case 7:	rootLayout.getStylesheets().add(getClass().getResource("/css/DarkTheme.css").toExternalForm()); break;
    		
    		default:rootLayout.getStylesheets().add(getClass().getResource("/css/DarkTheme.css").toExternalForm()); break;
    		
    	}  
    	rootLayout.getStylesheets().add(getClass().getResource("/css/Extensions.css").toExternalForm());
    	
    }

    private void handleTaskListScrolling() {
		ListView<ReadOnlyTask> scrollList = taskListPanel.getTaskListView();
		handlePageUp(scrollList);
		handlePageDown(scrollList);
	}

	public void handlePageDown(ListView<ReadOnlyTask> scrollList) {

		rootLayout.addEventFilter(KeyEvent.KEY_PRESSED, (KeyEvent event) -> {
			if (event.getCode() == KeyCode.PAGE_DOWN) {
				if ((taskPointer + 1) > logic.getFilteredTaskList().size() - 1)
				    taskPointer = 0;
				else {
                    taskPointer = taskPointer + 1;
				}
				scrollList.scrollTo(taskPointer);
			}
		});

	}
	

```
###### /java/main/ui/MainWindow.java
``` java
	public void handlePageUp(ListView<ReadOnlyTask> scrollList) {

		rootLayout.addEventFilter(KeyEvent.KEY_PRESSED, (KeyEvent event) -> {
			if (event.getCode() == KeyCode.PAGE_UP) {
				if ((taskPointer - 1) < 0)
	                taskPointer = logic.getFilteredTaskList().size() - 1;
				else {
					taskPointer = taskPointer - 1;
				}
				scrollList.scrollTo(taskPointer);
			}
		});
	}
	
```
###### /java/main/ui/ResultDisplay.java
``` java
package main.ui;


import javafx.beans.property.SimpleStringProperty;
import javafx.beans.property.StringProperty;
import javafx.scene.Node;
import javafx.scene.control.TextArea;
import javafx.scene.layout.AnchorPane;
import javafx.stage.Stage;
import main.commons.util.FxViewUtil;

/**
 * A ui for the status bar that is displayed at the header of the application.
 * "person" keyword check done
 * "addressbook" keyword check done
 * @author bey
 */
public class ResultDisplay extends UiPart {
    public static final String RESULT_DISPLAY_ID = "resultDisplay";
    private static final String STATUS_BAR_STYLE_SHEET = "result-display";
    private TextArea resultDisplayArea;
    private final StringProperty displayed = new SimpleStringProperty("");

    private static final String FXML = "ResultDisplay.fxml";

    private AnchorPane placeHolder;

    private AnchorPane mainPane;

    public static ResultDisplay load(Stage primaryStage, AnchorPane placeHolder) {
        ResultDisplay statusBar = UiPartLoader.loadUiPart(primaryStage, placeHolder, new ResultDisplay());
        statusBar.configure();
        return statusBar;
    }

    public void configure() {
        resultDisplayArea = new TextArea();
        resultDisplayArea.setEditable(false);
        resultDisplayArea.setId(RESULT_DISPLAY_ID);
        resultDisplayArea.getStyleClass().removeAll();
        resultDisplayArea.getStyleClass().add(STATUS_BAR_STYLE_SHEET);
        resultDisplayArea.setText("");
        resultDisplayArea.textProperty().bind(displayed);
        FxViewUtil.applyAnchorBoundaryParameters(resultDisplayArea, 0.0, 0.0, 0.0, 0.0);
        mainPane.getChildren().add(resultDisplayArea);
        FxViewUtil.applyAnchorBoundaryParameters(mainPane, 0.0, 0.0, 0.0, 0.0);
        placeHolder.getChildren().add(mainPane);
    }

    @Override
    public void setNode(Node node) {
        mainPane = (AnchorPane) node;
    }

    @Override
    public void setPlaceholder(AnchorPane placeholder) {
        this.placeHolder = placeholder;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    public void postMessage(String message) {
        displayed.setValue(message);
    }
    
    public void clearResultDisplay(){
    	displayed.setValue("");
    }

}
```
###### /java/main/ui/UiPartLoader.java
``` java
package main.ui;

import javafx.fxml.FXMLLoader;
import javafx.scene.Node;
import javafx.scene.layout.AnchorPane;
import javafx.stage.Stage;
import main.Main;


/**
 * A utility class to load UiParts from FXML files.
 * "person" keyword check done
 * "addressbook" keyword check done
 * @author bey
 */

public class UiPartLoader {
    private final static String FXML_FILE_FOLDER = "/view/";

    public static <T extends UiPart> T loadUiPart(Stage primaryStage, T controllerSeed) {
        return loadUiPart(primaryStage, null, controllerSeed);
    }

    /**
     * Returns the ui class for a specific UI Part.
     * @param primaryStage The primary stage for the view.
     * @param placeholder The placeholder where the loaded Ui Part is added.
     * @param sampleUiPart The sample of the expected UiPart class.
     * @param <T> The type of the UiPart
     */
    public static <T extends UiPart> T loadUiPart(Stage primaryStage, AnchorPane placeholder, T sampleUiPart) {
        FXMLLoader loader = new FXMLLoader();
        loader.setLocation(Main.class.getResource(FXML_FILE_FOLDER + sampleUiPart.getFxmlPath()));
        Node mainNode = loadLoader(loader, sampleUiPart.getFxmlPath());
        UiPart controller = loader.getController();
        controller.setStage(primaryStage);
        controller.setPlaceholder(placeholder);
        controller.setNode(mainNode);
        return (T)controller;
    }

    /**
     * Returns the ui class for a specific UI Part.
     *
     * @param seedUiPart The UiPart object to be used as the ui.
     * @param <T> The type of the UiPart
     */

    public static <T extends UiPart> T loadUiPart(T seedUiPart) {
        FXMLLoader loader = new FXMLLoader();
        loader.setLocation(Main.class.getResource(FXML_FILE_FOLDER + seedUiPart.getFxmlPath()));
        loader.setController(seedUiPart);
        loadLoader(loader, seedUiPart.getFxmlPath());
        return seedUiPart;
    }


    private static Node loadLoader(FXMLLoader loader, String fxmlFileName) {
        try {
            return loader.load();
        } catch (Exception e) {
            String errorMessage = "FXML Load Error for " + fxmlFileName;
            throw new RuntimeException(errorMessage, e);
        }
    }

}
```
###### /java/main/Main.java
``` java
package main;
 
import java.io.IOException;

import javafx.application.Application;
import javafx.stage.Stage;
import main.commons.events.ui.ExitAppRequestEvent;
import main.commons.exceptions.DataConversionException;
import main.commons.util.ConfigUtil;
import main.commons.util.StringUtil;
import main.commons.core.Config;
import main.commons.core.EventsCenter;
import main.commons.core.LogsCenter;
import main.commons.core.Version;
import main.logic.Logic;
import main.storage.Storage;
import main.storage.StorageManager;
import main.ui.MainWindow;
import main.ui.Ui;
import main.ui.UiManager;
import main.logic.LogicManager;

import com.google.common.eventbus.Subscribe;
import javafx.application.Platform;
import java.util.Map;
import java.util.Optional;
import java.util.logging.Logger;

import main.model.TaskTracker;
import main.model.Model;
import main.model.ModelManager;
import main.model.ReadOnlyTaskTracker;
import main.model.UserPrefs;


/**
 * The main entry point to the application.
 */
public class Main extends Application {
    private static final Logger logger = LogsCenter.getLogger(Main.class);

    public static final Version VERSION = new Version(1, 0, 0, true);

    protected Ui ui;
    protected Logic logic;
    protected Storage storage;
    protected Model model;
    protected Config config;
    protected UserPrefs userPrefs;
    protected int colourPointer;

    public Main() {}

    @Override
    public void init() throws Exception {
        logger.info("=============================[ Initializing Task-Tracker ]===========================");
        super.init();

        config = initConfig(getApplicationParameter("config"));
        storage = new StorageManager(config.getTaskTrackerFilePath(), config.getUserPrefsFilePath());

        userPrefs = initPrefs(config);

        initLogging(config);
        
        colourPointer = userPrefs.getColourPointer();

        model = initModelManager(storage, userPrefs);

        logic = new LogicManager(model, storage);

        ui = new UiManager(logic, config, userPrefs);

        initEventsCenter();
    }

    private String getApplicationParameter(String parameterName){
        Map<String, String> applicationParameters = getParameters().getNamed();
        return applicationParameters.get(parameterName);
    }

    private Model initModelManager(Storage storage, UserPrefs userPrefs) {
        Optional<ReadOnlyTaskTracker> taskTrackerOptional;
        ReadOnlyTaskTracker initialData;
        try {
        	taskTrackerOptional = storage.readTaskTracker();
            if(!taskTrackerOptional.isPresent()){
                logger.info("Data file not found. Will be starting with an empty TaskTracker");
            }
            initialData = taskTrackerOptional.orElse(new TaskTracker());
            logger.info(initialData.getTaskList().size() + "");
        } catch (DataConversionException e) {
            logger.warning("Data file not in the correct format. Will be starting with an empty TaskTracker");
            initialData = new TaskTracker();
        } catch (IOException e) {
            logger.warning("Problem while reading from the file. . Will be starting with an empty TaskTracker");
            initialData = new TaskTracker();
        }

        return new ModelManager(new TaskTracker(initialData), userPrefs);
    }

    private void initLogging(Config config) {
        LogsCenter.init(config);
    }

    protected Config initConfig(String configFilePath) {
        Config initializedConfig;
        String configFilePathUsed;

        configFilePathUsed = Config.DEFAULT_CONFIG_FILE;

        if(configFilePath != null) {
            logger.info("Custom Config file specified " + configFilePath);
            configFilePathUsed = configFilePath;
        }

        logger.info("Using config file : " + configFilePathUsed);

        try {
            Optional<Config> configOptional = ConfigUtil.readConfig(configFilePathUsed);
            initializedConfig = configOptional.orElse(new Config());
        } catch (DataConversionException e) {
            logger.warning("Config file at " + configFilePathUsed + " is not in the correct format. " +
                    "Using default config properties");
            initializedConfig = new Config();
        }

        //Update config file in case it was missing to begin with or there are new/unused fields
        try {
            ConfigUtil.saveConfig(initializedConfig, configFilePathUsed);
        } catch (IOException e) {
            logger.warning("Failed to save config file : " + StringUtil.getDetails(e));
        }
        return initializedConfig;
    }

    protected UserPrefs initPrefs(Config config) {
        assert config != null;

        String prefsFilePath = config.getUserPrefsFilePath();
        logger.info("Using prefs file : " + prefsFilePath);

        UserPrefs initializedPrefs;
        try {
            Optional<UserPrefs> prefsOptional = storage.readUserPrefs();
            initializedPrefs = prefsOptional.orElse(new UserPrefs());
        } catch (DataConversionException e) {
            logger.warning("UserPrefs file at " + prefsFilePath + " is not in the correct format. " +
                    "Using default user prefs");
            initializedPrefs = new UserPrefs();
        } catch (IOException e) {
            logger.warning("Problem while reading from the file. . Will be starting with an empty TaskTracker");
            initializedPrefs = new UserPrefs();
        }

        //Update prefs file in case it was missing to begin with or there are new/unused fields
        try {
            storage.saveUserPrefs(initializedPrefs);
        } catch (IOException e) {
            logger.warning("Failed to save config file : " + StringUtil.getDetails(e));
        }

        return initializedPrefs;
    }

    private void initEventsCenter() {
        EventsCenter.getInstance().registerHandler(this);
    }

    @Override
    public void start(Stage primaryStage) {
        logger.info("Starting Task-Tracker " + Main.VERSION);
        ui.start(primaryStage);
    }
    
    @Override
    public void stop() {
        logger.info("============================ [ Stopping Task-Tracker ] =============================");
        ui.stop();
        
        try {
            storage.saveUserPrefs(userPrefs);
        } catch (IOException e) {
            logger.severe("Failed to save preferences " + StringUtil.getDetails(e));
        }
        Platform.exit();
        System.exit(0);
    }

```
###### /java/main/Main.java
``` java
    @Subscribe
    public void handleExitAppRequestEvent(ExitAppRequestEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        this.stop();
    }

    public static void main(String[] args) {
        launch(args);
    }
}
```
###### /java/main/logic/command/DeleteCommand.java
``` java
package main.logic.command;

import main.model.task.UniqueTaskList.TaskNotFoundException;
import main.ui.ListStatistics;

/**
 * Deletes a task identified using it's last displayed index from the task tracker.
 * Prints success message and the corresponding deleted index.
 * @author bey
 */

public class DeleteCommand extends Command {
	public static final String COMMAND_WORD = "delete";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": " 
            + "Deletes the existing task by the index number shown in the list above.\n"
            + "Parameters: <task index>\n"
            + "Eg: " + COMMAND_WORD + " 1";


    public static final String MESSAGE_DELETE_TASK_SUCCESS = "Deleted Task: ";
    public static final String MESSAGE_DELETE_TASK_INVALID = "The task index provided is invalid";
    public static final String MESSAGE_DELETE_NO_TASK = "Task does not exist in Task-Tracker";
    
    private int taskIndex;

    public DeleteCommand(int targetVisibleIndex) {
        super(targetVisibleIndex);
        
        this.taskIndex = targetVisibleIndex;
    }


    @Override
    public CommandResult execute() {
        try {
            model.deleteTask(taskIndex);
            return new CommandResult(String.format(MESSAGE_DELETE_TASK_SUCCESS + (taskIndex+1) + "", taskIndex));

        } catch (IndexOutOfBoundsException ie) {
            return new CommandResult(MESSAGE_DELETE_TASK_INVALID);
        } catch (TaskNotFoundException pnfe) {
            return new CommandResult(MESSAGE_DELETE_NO_TASK);
        }
    }
}
```
###### /java/main/logic/command/ExitCommand.java
``` java
package main.logic.command;

import main.commons.core.EventsCenter;

import main.commons.events.ui.ExitAppRequestEvent;
import main.logic.command.CommandResult;

/**
 * Terminates the program.
 * EventsCenter is from commons and ExitApp is in UI. Remember to work on them.
 * @author bey
 */

public class ExitCommand extends Command{
	
	public static final String COMMAND_WORD = "exit";

	    public static final String MESSAGE_EXIT_ACKNOWLEDGEMENT = "Exiting Tracker-Tracker as requested ...";

		public static final String MESSAGE_USAGE = COMMAND_WORD + ": exits Task-Tracker";
 
		public ExitCommand() {
			super();
		}


	    @Override
	    //
	    public CommandResult execute() {
	        EventsCenter.getInstance().post(new ExitAppRequestEvent());
	        return new CommandResult(MESSAGE_EXIT_ACKNOWLEDGEMENT);
	    }
	
}
```
###### /java/main/logic/command/CommandResult.java
``` java
package main.logic.command;

/**
 * Represents the result of a command execution.
 * @author bey
 */
public class CommandResult {

    public final String feedbackToUser;
    
    public CommandResult(String feedbackToUser) {
        assert feedbackToUser != null;
        this.feedbackToUser = feedbackToUser;
    }

}
```
###### /java/main/logic/command/AddCommand.java
``` java
import main.model.task.Task;
import main.model.task.UniqueTaskList;
import main.ui.ListStatistics;

/**
 * Adds a task to the task-tracker storage.
 * @author bey
 */
public class AddCommand extends Command {
    
    public static final String COMMAND_WORD = "add";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Adds a task to the to do list.\n"
            + "Parameters: <task> [date1] [date2] [priority] \n"
            + "Eg: " + COMMAND_WORD + " add wash dishes monday 4pm -h";

    public static final String MESSAGE_SUCCESS = "New task added: %1$s";
    public static final String MESSAGE_DUPLICATE_TASK = "This task is already in the to do list";
    
    Task toAdd;

    public AddCommand(Task task) {
        toAdd = task;
    }

    /**
     * //Remember to add validator in Model component
		//Possible to add Traynotification here.
     */
	@Override
	public CommandResult execute() {
		try {
            model.addTask(toAdd);
            return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd));
		}
		catch (UniqueTaskList.DuplicateTaskException e) {
		    return new CommandResult(MESSAGE_DUPLICATE_TASK);
		}
        
	}
}
```
###### /java/main/logic/command/Command.java
``` java
package main.logic.command;

import main.commons.core.EventsCenter;
import main.commons.core.Messages;

import main.commons.events.ui.IncorrectCommandAttemptedEvent;
import main.model.Model;
import main.storage.Storage;

/**
 * Represents a command with hidden internal logic and the ability to be executed.
 * @author bey
 */
public abstract class Command {
	protected Model model;
	protected Storage storage;
	private int targetIndex = -1;
//	/**
//     * @param targetIndex last visible listing index of the target task
//     */
	public Command(int targetIndex) {
        this.setTargetIndex(targetIndex);
    }
	
	public Command() {}
	
	public void setTargetIndex(int targetIndex) {
        this.targetIndex = targetIndex;
    }
    /**
     * Constructs a feedback message to summarise an operation that displayed a listing of persons.
     *
     * @param displaySize used to generate summary
     * @return summary message for persons displayed
     */
    public static String getMessageForPersonListShownSummary(int displaySize) {
        return String.format(Messages.MESSAGE_TASK_LISTED_OVERVIEW, displaySize);
    }

    /**
     * Executes the command and returns the result message.
     *
     * @return feedback message of the operation result for display
     */
    public abstract CommandResult execute();

    /**
     * Provides any needed dependencies to the command.
     * Commands making use of any of these should override this method to gain
     * access to the dependencies.
     */
    public void setData(Model model) {
        this.model = model;
    }
    
```
###### /java/main/logic/command/IncorrectCommand.java
``` java
package main.logic.command;

/**
 * Represents an incorrect command. Upon execution, produces some feedback to the user.
 * @author bey
 */

public class IncorrectCommand extends Command {

    public final String feedbackToUser;

    public IncorrectCommand (String feedbackToUser){
        this.feedbackToUser = feedbackToUser;
    }

    @Override
    public CommandResult execute() {
        indicateAttemptToExecuteIncorrectCommand();
        return new CommandResult(feedbackToUser);
    }

}
```
###### /java/main/logic/command/HelpCommand.java
``` java
package main.logic.command;

import main.commons.core.EventsCenter;
import main.commons.events.ui.ShowHelpRequestEvent;
import main.logic.command.CommandResult;

/**
 * Format full help instructions for every command for display.
 * @author bey
 */

public class HelpCommand extends Command {
    
	public static final String COMMAND_WORD = "help";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Shows program usage instructions.\n"
            + "Example: " + COMMAND_WORD;

    public static final String SHOWING_HELP_MESSAGE = "Opened help window.";

    public HelpCommand() {}

    @Override
    public CommandResult execute() {
        EventsCenter.getInstance().post(new ShowHelpRequestEvent());
        return new CommandResult(SHOWING_HELP_MESSAGE);
    }
}
```
###### /java/main/logic/command/EditCommand.java
``` java
package main.logic.command;

import java.util.Date;

import main.commons.exceptions.IllegalValueException;
import main.model.task.Task;
import main.model.task.UniqueTaskList.DuplicateTaskException;
import main.model.task.UniqueTaskList.TaskNotFoundException;

/**
 * Edits an existing task in task-tracker
 * @author 
 *
 */
```
###### /java/main/logic/command/EditCommand.java
``` java
public class EditCommand extends Command {
public static final String COMMAND_WORD = "edit";
	
	public static final String MESSAGE_USAGE = COMMAND_WORD + ": " + "Edits a task in the Task-Tracker.\n"
												+ "Parameters: [task] [date] [time]\n"
												+ "Eg: " + COMMAND_WORD
												+ "2 wash dishes tuesday 6pm -h";
	
	public static final String MESSAGE_SUCCESS = "Task changed to: %1$s";
	public static final String MESSAGE_NO_SUCH_TASK = "This task does not exist in the Task-Tracker";
	
	private Task toEdit;
	private final int editNum;
	private Task newTask;
	
	public EditCommand(int targetVisibleIndex, Task newTask) {
		super(targetVisibleIndex);
		editNum = targetVisibleIndex;
		this.newTask = newTask;
	}	
	
	@Override
	public CommandResult execute() {
		try {
		    model.deleteTask(editNum);
			model.addTask(newTask);
			return new CommandResult(String.format(MESSAGE_SUCCESS, newTask));
		}catch (TaskNotFoundException e){
            return new CommandResult("Task does not exist in task-tracker");
		}catch (IndexOutOfBoundsException ie) {
			return new CommandResult("The task index provided is invalid");
		}catch (DuplicateTaskException e) {
            return new CommandResult(AddCommand.MESSAGE_DUPLICATE_TASK);
		}
	}
	
	
}
```
###### /java/main/logic/command/DoneCommand.java
``` java
package main.logic.command;

import main.model.task.Task;
import main.model.task.UniqueTaskList.TaskNotFoundException;

public class DoneCommand extends Command{
	
	public static final String COMMAND_WORD = "done";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Indicates a task to be done\n"
            + "Parameters: <task index>\n"
            + "Eg: " + COMMAND_WORD + " 1";

    public static final String MESSAGE_SUCCESS = "The following task is done: %1$s";
    public static final String MESSAGE_TASK_ALREADY_DONE = "This task is already marked as done";
    
    private int taskIndex;

    public DoneCommand(int targetVisibleIndex) {
        super(targetVisibleIndex);
        
        this.taskIndex = targetVisibleIndex;
    }


    @Override
    public CommandResult execute() {
        try {
        	//Remove comment after Model component adds a setIsDone() method which changes the value of 
        	//it isDone attribute.

            model.doneTask(taskIndex);

            return new CommandResult(String.format(MESSAGE_SUCCESS, taskIndex+1));


        } catch (IndexOutOfBoundsException ie) {
            return new CommandResult("The task index provided is invalid");
        } 
        catch (TaskNotFoundException pnfe) {
            return new CommandResult("Task does not exist in task-tracker");
        }
    }

}
```
