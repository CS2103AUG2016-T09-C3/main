# A0144132W
###### \java\main\commons\core\Config.java
``` java
    public Config(String taskTrackerFilePath) {
        this.taskTrackerFilePath = taskTrackerFilePath;
    }
    
```
###### \java\main\commons\core\Messages.java
``` java
    public static final String MESSAGE_EMPTY_DESCRIPTION = "Task description must be provided \n %1$s ";
    public static final String MESSAGE_MULTIPLE_PRIORITY = "Task can only have 1 priority level \n";
    public static final String MESSAGE_INVALID_PARAMETERS = "Invalid %1$s parameters! \n %2$s";
    public static final String MESSAGE_INVALID_INDEX = "Invalid index. Index starts from 1! \n %1$s ";
    
}
```
###### \java\main\commons\events\model\ChangeSortFilterEvent.java
``` java
package main.commons.events.model;

import main.commons.events.BaseEvent;
import main.model.filter.SortCriteria;

public class ChangeSortFilterEvent extends BaseEvent {

    private SortCriteria filter;
    
    public ChangeSortFilterEvent(String param) {
        assert "date".equals(param) || "name".equals(param);
        matchToFilter(param);
    }

    private void matchToFilter(String param) {
        if ("date".equals(param)) {
            filter = SortCriteria.TIME;
        }
        else {
            filter = SortCriteria.NAME;
        }
    }
    
    public SortCriteria getSortCriteria() {
        return filter;
    }

    @Override
    public String toString() {
        return filter.name();
    }

}
```
###### \java\main\commons\events\model\LoadTaskTrackerEvent.java
``` java
package main.commons.events.model;

import main.commons.events.BaseEvent;
import main.model.ReadOnlyTaskTracker;

public class LoadTaskTrackerEvent extends BaseEvent{
    private ReadOnlyTaskTracker taskTracker;
    
    public LoadTaskTrackerEvent(ReadOnlyTaskTracker taskTracker) {
        this.taskTracker = taskTracker;
    }
    
    public ReadOnlyTaskTracker getTaskTracker() {
        return taskTracker;
    }

    @Override
    public String toString() {
        return taskTracker.toString();
    }
    
    

}
```
###### \java\main\commons\events\model\UpdateListWithSuggestionsEvent.java
``` java
package main.commons.events.model;

import java.util.List;

import main.commons.events.BaseEvent;
import main.model.task.ReadOnlyTask;

public class UpdateListWithSuggestionsEvent extends BaseEvent {
    private List<ReadOnlyTask> suggestions;
    
    public UpdateListWithSuggestionsEvent(List<ReadOnlyTask> suggestions) {
        this.suggestions = suggestions;
    }
    
    public List<ReadOnlyTask> getSuggestions() {
        return suggestions;
    }

    @Override
    public String toString() {
        return "" + suggestions.size() + " matching tasks found";
    }

}
```
###### \java\main\commons\events\storage\FilePathChangedEvent.java
``` java
package main.commons.events.storage;

import main.commons.events.BaseEvent;
import main.model.ReadOnlyTaskTracker;

public class FilePathChangedEvent extends BaseEvent{
    String filePath;
    ReadOnlyTaskTracker taskTracker;

    public FilePathChangedEvent(String filePath, ReadOnlyTaskTracker taskTracker) {
        this.filePath = filePath;
        this.taskTracker = taskTracker;
    }
    
    public String getFilePath() {
        return filePath;
    }
    
    public ReadOnlyTaskTracker getTaskTracker() {
        return taskTracker;
    }

    @Override
    public String toString() {
        return filePath;
    }
}
```
###### \java\main\commons\events\ui\AutoCompleteEvent.java
``` java
package main.commons.events.ui;

import main.commons.events.BaseEvent;

public class AutoCompleteEvent extends BaseEvent{
    
    // the start and end index of the input to be replaced
    private int start;
    private int end;
    
    private String suggestion;
    
    public AutoCompleteEvent(int start, int end, String suggestion) {
        this.suggestion = suggestion;
        this.start = start;
        this.end = end;
    }
    
    public String getSuggestion() {
        return suggestion;
    }
    
    public int getStart() {
        return start;
    }
    
    public int getEnd() {
        return end;
    }
    
    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### \java\main\commons\events\ui\KeyPressEvent.java
``` java
package main.commons.events.ui;

import main.commons.events.BaseEvent;

public class KeyPressEvent extends BaseEvent{
    private String input;

    public KeyPressEvent(String input) {
        this.input = input;
    }
    
    public String getInput() {
        return input;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }
    

}
```
###### \java\main\commons\events\ui\TabPressEvent.java
``` java
package main.commons.events.ui;

import main.commons.events.BaseEvent;

public class TabPressEvent extends BaseEvent{  
    
    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### \java\main\commons\events\ui\updateListStatisticsPictureEvent.java
``` java
package main.commons.events.ui;

import java.util.Map;

import com.google.common.collect.ImmutableMap;

import main.commons.events.BaseEvent;
import main.model.task.PriorityType;
import main.model.task.TaskType;

public class updateListStatisticsPictureEvent extends BaseEvent{
    
    private String parameter;
    private static final Map<String, String> linkToFilePath = ImmutableMap.<String, String>builder()
            .put(PriorityType.HIGH.name(), "/images/high.png")
            .put(PriorityType.NORMAL.name(), "/images/normal.png")
            .put(PriorityType.LOW.name(), "/images/low.png")
            .put(TaskType.DEADLINE.name(), "/images/deadlines.png")
            .put(TaskType.EVENT.name(), "/images/events.png")
            .put(TaskType.FLOATING.name(), "/images/floating.png")
            .put("date", "/images/calendar.png")            
            .put("list", "/images/statistics.png")
            .put("overdue", "/images/overdue.png")
            .build();
    
    /*
     * updates the picture in list statistics according to the parameter passed
     * 
     * parameter is limited to the keys in linkToFilePath 
     */
    public updateListStatisticsPictureEvent(String parameter) {
        this.parameter = parameter;
    }
    
    public String getImageFilePath() {
        if (!linkToFilePath.containsKey(parameter)) {
            return linkToFilePath.get("list"); // in case parameter is passed wrongly
        }
        else {
            return linkToFilePath.get(parameter);
        }
    }

    @Override
    public String toString() {
        return parameter;
    }
}
```
###### \java\main\commons\exceptions\MultiplePriorityException.java
``` java
package main.commons.exceptions;

public class MultiplePriorityException extends IllegalArgumentException {
    public MultiplePriorityException() {
        super();
    }
}
```
###### \java\main\commons\util\DateUtil.java
``` java
package main.commons.util;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;

public class DateUtil {
    
    /**
     * convenient constructor for Date, with time
     * 
     * @returns a Date object
     */
    public static Date getDate(int year, int month, int day, int hour, int min){
        Calendar cal = Calendar.getInstance();
        cal.set(year, month, day, hour, min);
        return cal.getTime();
    }

    /**
     * convenient constructor for Date, without time
     * 
     * @returns a Date object
     */
    public static Date getDate(int year, int month, int day){
        Calendar cal = Calendar.getInstance();
        cal.set(year, month, day);
        return cal.getTime();
    }
    
    /**
     * @returns today's date
     */
    public static Date getToday(){
        Calendar cal = Calendar.getInstance();
        return setTime(cal.getTime(), 8, true);
    }
    
    public static Date getTmr() {
        Calendar cal = Calendar.getInstance();
        cal.setTime(getToday());
        cal.add(Calendar.DATE, 1);
        return cal.getTime();
    }
     
    /**
     * @returns true if the given date overlaps with the given the start and end date
     */
    public static boolean dateOverlap(Date start, Date end, Date date) {
        if (start == null || end == null || date == null) {
            return false;
        }
        
        return ((start.before(date) && end.after(date)) 
                || (areSameDay(start, date) && areSameDay(end, date)));

    }
    
    /**
     * compares the 2 dates, not including the time
     * 
     * @returns true if both dates are on the same day
     */
    public static boolean areSameDay(Date date1, Date date2) {
        if (date1 == null | date2 == null) {
            return false;
        }
        Calendar cal1 = Calendar.getInstance();
        cal1.setTime(date1);
        
        Calendar cal2 = Calendar.getInstance();
        cal2.setTime(date2);
        
        if ((cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR)) 
            && (cal1.get(Calendar.MONTH) == cal2.get(Calendar.MONTH)) 
            && (cal1.get(Calendar.DATE) == cal2.get(Calendar.DATE))) {
            return true;
        }
        else return false;
    }
    
    
    /**
     * @returns a date with a nice readable format
     */
    public static String readableDate(Date date, boolean isInferred) {
        DateFormat df;
        if (isInferred) {
            df = new SimpleDateFormat("dd MMM");
        }
        else {
            df = new SimpleDateFormat("dd MMM h:mm a");            
        }
        return df.format(date);
    }
    
    /**
     * takes isInferred as true by default
     * 
     * @returns a a date with a nice readable format, without time
     */
    public static String readableDate(Date date) {
        return readableDate(date, true);
    }
    
    /**
     * changes the time to the hour given (in 24 hours format) and
     * resets minutes, depending on the boolean input
     *       
     * @returns the original date with given time
     */
    public static Date setTime(Date date, int hour, boolean resetMinutes) {
        Calendar cal = Calendar.getInstance();
        cal.setTime(date);
        cal.set(Calendar.HOUR_OF_DAY, hour);
        if (resetMinutes) {
            cal.clear(Calendar.MINUTE);
            cal.clear(Calendar.SECOND);
            cal.clear(Calendar.MILLISECOND);
        }
        return cal.getTime();
    }
```
###### \java\main\commons\util\DateUtil.java
``` java
    public static Date defaultTime(Date date) {
        return setTime(date, 8, true);
    }
}

```
###### \java\main\commons\util\FileUtil.java
``` java
    /*
     * checks if path given is valid.
     * @param path cannot be null.
     */
    public static boolean isValidPath(String path) {
        assert path != null;
        try {
            File file = new File(path);
            FileUtil.createIfMissing(file);
        } catch (IOException e) {
            return false;
        }
        
        return true;
    }
}
```
###### \java\main\logic\autocomplete\AutoComplete.java
``` java
package main.logic.autocomplete;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.logging.Logger;
import java.util.stream.Collectors;

import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.StringUtils;

import com.google.common.eventbus.Subscribe;

import org.apache.commons.lang3.tuple.Pair;
import main.commons.core.EventsCenter;
import main.commons.core.LogsCenter;
import main.commons.events.model.TaskTrackerChangedEvent;
import main.commons.events.model.UpdateListWithSuggestionsEvent;
import main.commons.events.ui.AutoCompleteEvent;
import main.commons.events.ui.KeyPressEvent;
import main.commons.events.ui.TabPressEvent;
import main.logic.autocomplete.SetTrie.TrieBuilder;
import main.logic.command.DeleteCommand;
import main.logic.command.DoneCommand;
import main.logic.command.EditCommand;
import main.logic.command.FindCommand;
import main.logic.command.ListCommand;
import main.logic.command.SortCommand;
import main.logic.parser.ReferenceList;
import main.model.Model;
import main.model.task.ReadOnlyTask;

public class AutoComplete {
        
    private static final Logger logger = LogsCenter.getLogger(AutoComplete.class);

    private SetTrie commandList;
    private SetTrie listList;
    private SetTrie sortList;
    private List<Pair<ReadOnlyTask,SetTrie>> taskList;
    private List<String> suggestions;
    private int start_index;
    private int end_index;
    private int tabCount = 0;
    EventsCenter eventsCenter;
    Model model;
    
    // to return to original list (when showing matching tasks in real time)
    private boolean save = false;
    private boolean revert = false;
    
    public AutoComplete(Model model) {
        this.eventsCenter = EventsCenter.getInstance().registerHandler(this);
        this.model = model;        
        buildAllLists();
        initSuggestions();
    }

    /**
     * Fills the suggestions list with all commands at start up.
     */
    private void initSuggestions() {
        suggestions = commandList.getSuggestions("");
    }
    
    private void buildAllLists() {
        buildCommandList();
        buildListList();
        buildSortList();
        taskList = new ArrayList<Pair<ReadOnlyTask,SetTrie>>();
        updateTaskList();
    }
    
    private void buildCommandList() {
        TrieBuilder build = SetTrie.builder().caseInsensitive();
        build.add(ReferenceList.CommandsSetWithRelevantSpaces);
        commandList = build.build();
    }
 
    private void buildListList() {
        TrieBuilder build = SetTrie.builder().caseInsensitive();
        build.add(ReferenceList.listSet);
        listList = build.build();
    }
    
    private void buildSortList() {
        TrieBuilder build = SetTrie.builder().caseInsensitive();
        build.add(ReferenceList.sortSet);
        sortList = build.build();
    }
    
    /**
     * Updates the taskList by iterating all tasks and storing
     * them into an array of SetTrie.
     */
    private void updateTaskList() {

        for (ReadOnlyTask task: model.getTaskTracker().getTaskList()) {
            SetTrie trie = SetTrie.builder().caseInsensitive()
                                  .add(Arrays.stream(getTokens(task.getMessage())).collect(Collectors.toSet()))
                                  .build();

            taskList.add(Pair.of(task,trie));
        }
    }
    
    private String[] getTokens(String input) {
        return input.trim().split(" ");
    }
    
    public void updateSuggestions(String input) {
        String[] tokens = getTokens(input);
        end_index = input.length();
        
        // if there is only 1 token, take as command word
        if (tokens.length == 1) {
            suggestions = commandList.getSuggestions(input);
            start_index = 0;
            
            revertIfNeeded();
            save = true;
        }
        else {
            String commandInput = tokens[0];
            
            if (ReferenceList.commandsDictionary.containsKey(commandInput)) {
                String commandWord = ReferenceList.commandsDictionary.get(commandInput);
                deduceSuggestionsToGive(tokens, commandInput, commandWord);
            }
        }
        updateTaskList();
    }

    /**
     * Deduces the appropriate suggestions to give based on commandWord.
     */
    private void deduceSuggestionsToGive(String[] tokens, String commandInput, String commandWord) {

        if (needTaskSuggestions(tokens, commandWord)) {
            start_index = commandInput.length() + 1;
            saveIfNeeded(commandWord);
            getTaskSuggestions(tokens);
        }
        else if (commandWord.equals(ListCommand.COMMAND_WORD)) {
            start_index = getListSuggestions(tokens);
        }
        else if (commandWord.equals(SortCommand.COMMAND_WORD) && tokens.length == 2) {
            getSortSuggestions(tokens[1]);
            start_index = commandInput.length() + 1;
        }
    }

    /**
     * Saves the filter just before list starts to give real time suggestions 
     */
    private void saveIfNeeded(String commandWord) {
        if (save) {
            save = false;
            
            if (!commandWord.equals(FindCommand.COMMAND_WORD)) {
                model.saveFilter();
                revert = true;
            }
        }
    }

    /**
     * Reverts to original filter when user cancels search.
     */
    private void revertIfNeeded() {
        if (revert) {
            model.revertFilter();
            revert = false;
        }
    }
    
    private void getSortSuggestions(String token) {
        suggestions = sortList.getSuggestions(token);
    }
    
    /**
     * Gets suggestions for last list parameter
     * 
     * @returns the start index of the command input to be replaced
     */
    private int getListSuggestions(String[] tokens) {
        suggestions = listList.getSuggestions(tokens[tokens.length-1]);
       
        int index = 0;
        for (int i = 0; i < tokens.length - 1; i++) {
            index += tokens[i].length() + 1;
        }
        
        return index;
    }

    /**
     * @returns suggestions for tasks.
     */
    private void getTaskSuggestions(String[] tokens) {
        int size = updateFilteredListWithSuggestions(ArrayUtils.subarray(tokens, 1, tokens.length));
        suggestions = getStringArrayFromIndex(size);
    }
    
    /**
     * Determines when tasks suggestions are given. 
     */
    private boolean needTaskSuggestions(String[] tokens, String commandWord) {
        return (isEditDoneDelete(commandWord) || (commandWord.equals(FindCommand.COMMAND_WORD))) && !dontInterrupt(tokens, commandWord); 
    }

    /**
     * @returns true when user are using edit, done or delete command to execute instructions
     * (when inputs are numeric) rather than find tasks
     */
    private boolean dontInterrupt(String[] tokens, String commandWord) {
        return !commandWord.equals(FindCommand.COMMAND_WORD) && StringUtils.isNumeric(tokens[1]);
    }

    private boolean isEditDoneDelete(String commandWord) {
        return commandWord.equals(EditCommand.COMMAND_WORD) || commandWord.equals(DeleteCommand.COMMAND_WORD) || commandWord.equals(DoneCommand.COMMAND_WORD);
    }
    
    /**
     * Updates the filtered list in real time to show matching tasks.
     * 
     * @returns the size of the updated filtered list.
     */
    public int updateFilteredListWithSuggestions(String[] tokens) {
        taskList = taskList.stream().filter(pair -> containPrefixInTask(pair.getValue(), tokens)).collect(Collectors.toList());
        List<ReadOnlyTask> matchedTasks = getListOfMatchedTasks();
        eventsCenter.post(new UpdateListWithSuggestionsEvent(matchedTasks));
        return matchedTasks.size();
    }

    /**
     * Checks if task contains any prefix found in the given token array.
     */
    private boolean containPrefixInTask(SetTrie task, String[] tokens) {
        for (String token : tokens) {
            if (task.matchPrefix(token)) {
                return true;
            }
        }
        return false;
    }
    
    /**
     * @returns a list of tasks that matches the suggestions.
     */
    private List<ReadOnlyTask> getListOfMatchedTasks() {
        List<ReadOnlyTask> matchedTasks = new ArrayList<ReadOnlyTask>();
        
        for (ReadOnlyTask task : model.getTaskTracker().getTaskList()) {
            for (Pair<ReadOnlyTask,SetTrie> pair : taskList) {
                if (task.equals(pair.getKey())){
                    matchedTasks.add(task);
                    break;
                }
            }
        }
        return matchedTasks;
    }
    
    /**
     * Generates an array of index, starting from 1, corresponding 
     * to the number of tasks shown.
     */
    private List<String> getStringArrayFromIndex(int size) {
        List<String> list = new ArrayList<String>();
        for (int i = 1; i <= size; i++) {
            list.add(String.valueOf(i));
        }
        return list;
    }
    
    /**
     * Posts an AutoCompleteEvent to fill the commandBox.
     */
    public void fillInSuggestions() {
        if (suggestions.size() == 0) return;
        
        String suggest = suggestions.get(tabCount % suggestions.size());

        eventsCenter.post(new AutoCompleteEvent(start_index, end_index, suggest));
        end_index = start_index + suggest.length();
        
    }
    
    /**
     * @returns suggestions.
     */
    public List<String> getSuggestions() {
        return suggestions;
    }
    
    /**
     * Updates suggestions when key press is detected.
     */
    @Subscribe
    public void handleKeyPressEvent(KeyPressEvent event) {
        updateSuggestions(event.getInput());
        tabCount = 0;
    }
    
    /**
     * Toggles the suggestions to fill in commandBox.
     */
    @Subscribe
    public void handleTabPressEvent(TabPressEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        fillInSuggestions();
        tabCount++;
    }
    
    /**
     * Updates taskList when tasks are changed.
     */
    @Subscribe
    public void handleTaskTrackerChangedEvent(TaskTrackerChangedEvent event) {
        updateTaskList();
    }

}
```
###### \java\main\logic\autocomplete\SetTrie.java
``` java
package main.logic.autocomplete;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;
import java.util.stream.Collectors;

// Referenced from http://sujitpal.blogspot.sg/2007/02/three-autocomplete-implementations.html
public class SetTrie {

    private TreeSet<String> wordList;
    private boolean caseInsensitive; 
    

    public SetTrie(TreeSet<String> wordList, boolean caseInsensitive) {
        this.wordList = wordList;
        this.caseInsensitive = caseInsensitive;
        if (caseInsensitive) {
            this.wordList = this.wordList.stream().map(String::toLowerCase).collect(Collectors.toCollection(TreeSet::new));
        }
        
    }
   
    public boolean matchPrefix(String prefix) {
        if (caseInsensitive) {
            prefix = prefix.toLowerCase();
        }

        Set<String> tailSet = wordList.tailSet(prefix);
        for (String tail : tailSet) {
            if (tail.startsWith(prefix)) {
                return true;
            }
        }
        return false;
    }
    
    public List<String> getSuggestions(String prefix) {
        if (caseInsensitive) {
            prefix = prefix.toLowerCase();
        }

        List<String> possibleList = new ArrayList<String>();
        Set<String> tailSet = wordList.tailSet(prefix);
        for (String tail : tailSet) {
            if (tail.startsWith(prefix)) {
                possibleList.add(tail);
            } 
            else {
                break;
            }
        }
        return possibleList;
    }
    
    @Override
    public String toString(){
        StringBuilder stringBuilder = new StringBuilder();
        
        for (String word : wordList) {
            stringBuilder.append(word).append(" ");
        }
        return stringBuilder.toString().trim();
    }
    
    public static TrieBuilder builder() {
        return new TrieBuilder();
    }
    
    public static TrieBuilder builder(SetTrie trie) {
        return new TrieBuilder(trie);
    }
    
    public static class TrieBuilder {
        
        private TreeSet<String> wordList;
        private boolean caseInsensitive = false;
        
        private TrieBuilder() {
            wordList = new TreeSet<String>();
        }
        
        private TrieBuilder(SetTrie trie) {
            trie.wordList = new TreeSet<String>();
        }
        
        
        public TrieBuilder caseInsensitive() {
            this.caseInsensitive = true;
            return this;
        }
        
        public TrieBuilder add(Collection<String> words) {
            wordList.addAll(words);
            return this;
        }
        
        public SetTrie build() {
            return new SetTrie(wordList, caseInsensitive);
        }        
    }
}
```
###### \java\main\logic\command\ClearCommand.java
``` java
package main.logic.command;

import main.model.ReadOnlyTaskTracker;
import main.model.TaskTracker;
import main.model.task.UniqueTaskList;

/**
 * Clears the entire list of tasks from T-T storage
 *
 */
public class ClearCommand extends Command {
    
    public static final String COMMAND_WORD = "clear";
    public static final String MESSAGE_USAGE = COMMAND_WORD;
    public static final String MESSAGE_SUCCESS = "Task-Tracker has been cleared!";
    
    public ClearCommand() {}

    @Override
    public CommandResult execute() {
        model.resetData((ReadOnlyTaskTracker) new TaskTracker(new UniqueTaskList()));
        return new CommandResult(MESSAGE_SUCCESS);
    }
}
```
###### \java\main\logic\command\FindCommand.java
``` java
package main.logic.command;

public class FindCommand extends Command {
    
    public static final String COMMAND_WORD = "find";
    public static final String MESSAGE_USAGE = COMMAND_WORD + "Parameters: [keywords] \n"
            												+ "Type in keywords found in the desired task's description \n"
            												+ "Eg: " + COMMAND_WORD + " cs2103";
    public static final String MESSAGE_SUCCESS = "Found %1$s matching tasks";
        
    public FindCommand() {}
    
    @Override
    public CommandResult execute() {
        return new CommandResult(String.format(MESSAGE_SUCCESS, model.getFilteredTaskList().size()));
    }
    
}
```
###### \java\main\logic\command\ListCommand.java
``` java
package main.logic.command;

import java.util.Date;
import org.apache.commons.lang3.tuple.Triple;
import main.commons.util.DateUtil;
import main.model.task.PriorityType;
import main.model.task.TaskType;

/**
 * Lists certain tasks in the task tracker to the user.
 */
public class ListCommand extends Command {
    
    public static final String COMMAND_WORD = "list";
    public static final String MESSAGE_USAGE = COMMAND_WORD + "Parameters: [priority] [date] [type] \n"
            												+ "All parameters optional and interchangeable \n"
            												+ "Eg: " + COMMAND_WORD + " high today";
    public static final String MESSAGE_SUCCESS = "Listed all %1$s";
    
    private PriorityType priority;
    private Date date;
    private TaskType type;
    private boolean isDefault = false;
    private boolean isDone = false;
    private boolean onlyOverdue = false;
    
    public ListCommand() {
        isDefault = true;
    }
      
    public ListCommand(PriorityType priority, Date date, TaskType type, boolean isDone, boolean onlyOverdue) {
        this.priority = priority;
        this.date = date;
        this.type = type;
        this.isDone = isDone;
        this.onlyOverdue = onlyOverdue;
    }

	@Override
	public CommandResult execute() {

	    if (isDefault) model.updateFilteredListToShowAllPending();
	    else model.updateFilteredTaskList(Triple.of(priority, date, type), isDone, onlyOverdue);
	    
	    return new CommandResult(String.format(MESSAGE_SUCCESS, getReadableCriteria()));    
	}
	
	/**
	 * @returns String which consolidates the list parameters to something readable 
	 */
	private String getReadableCriteria() {
	    StringBuilder readable = new StringBuilder();
	 
	    String prefix = getPrefix();
	    String task = getReadableTaskType();
	    String priority_str = getPriority();
	    String date_str = getReadableDate();
	    
	    readable.append(prefix).append(priority_str).append(task).append(date_str);
	    
	    return readable.toString();
	    
	}
	
	private String getReadableDate() {
	    String date_str;
	    
	    if (date != null) {
	        date_str = " due " + DateUtil.readableDate(date, true);
	    }
	    else {
	        date_str = "";
	    }
	    return date_str;
	}

    private String getPriority() {
        String priority_str;
        
        if (priority == null) {
	        priority_str = " ";
	    }
	    else if (priority == PriorityType.LOW) {
	        priority_str = " low priority ";
	    }
	    else if (priority == PriorityType.HIGH) {
	        priority_str = " high priority ";
	    }
	    else {
	        priority_str = " normal priority ";
	    }
        
        return priority_str;
    }

    private String getPrefix() {
        String prefix;
        if (isDone) {
	        prefix = "completed";
	    }
	    else if (onlyOverdue) {
	        prefix = "overdue";
	    }
	    else {
	        prefix = "pending";
	    }
        return prefix;
    }

    private String getReadableTaskType() {
        String task;
        if (type == null) {
	        task = "tasks";
	    }
	    else if (type == TaskType.EVENT) {
	        task = "events";
	    }
        else if (type == TaskType.DEADLINE) {
            task = "tasks with deadlines";
        }
        else {
            task = "floating tasks";
        }
        return task;
    }
}
```
###### \java\main\logic\command\SortCommand.java
``` java
package main.logic.command;

import main.commons.core.EventsCenter;
import main.commons.events.model.ChangeSortFilterEvent;

/**
 * Sorts and displays the list of tasks lexicographically or by their deadlines
 */
public class SortCommand extends Command {
    
    public static final String COMMAND_WORD = "sort";
    public static final String MESSAGE_USAGE = COMMAND_WORD + "Parameters: <date | name> \n"
    														+ "Parameter can only be 'date' or 'name' \n"
    														+ "Eg: " + COMMAND_WORD + " date";
    public static final String MESSAGE_SUCCESS = "Sorting by %1$s";
    
    private String param;
    public SortCommand(String param) {
        this.param = param;
    }

    @Override
    public CommandResult execute() {
        assert (param.equals("date") || param.equals("name"));

        EventsCenter.getInstance().post(new ChangeSortFilterEvent(param));
        return new CommandResult(String.format(MESSAGE_SUCCESS, param));
    }
    

}
```
###### \java\main\logic\Logic.java
``` java
// adapted from addressbook level 4
package main.logic;

import javafx.collections.ObservableList;
import main.logic.command.CommandResult;
import main.model.task.ReadOnlyTask;

public interface Logic {
    
    /**
     * Executes the command and returns the result.
     * @param commandText The command as entered by the user.
     * @return the result of the command execution.
     */
    public CommandResult execute(String input);
    
    /** Returns the filtered list of persons */
    ObservableList<ReadOnlyTask> getFilteredTaskList();

    /** Returns the number of tasks due or happening today **/
    int getNumToday();

    /** Returns the number of tasks due or happening the next day **/
    int getNumTmr();
    
    /** Returns the number of events in the list **/
    int getNumEvent();

    /** Returns the number of tasks with deadline in the list **/
    int getNumDeadline();
    
    /** Returns the number of floating tasks in the list **/    
    int getNumFloating();

    int getTotalNum();

    int getNumOverdue();

}
```
###### \java\main\logic\LogicManager.java
``` java
package main.logic;

import main.commons.core.LogsCenter;
import main.commons.core.ComponentManager;
import main.logic.autocomplete.AutoComplete;
import main.logic.command.Command;
import main.logic.command.CommandResult;
import main.logic.parser.MainParser;
import main.model.Model;
import main.model.task.ReadOnlyTask;
import main.storage.Storage;

import java.util.logging.Logger;

import javafx.collections.ObservableList;

/**
 * The main LogicManager of the app.
 */
public class LogicManager extends ComponentManager implements Logic {
    private final Logger logger = LogsCenter.getLogger(LogicManager.class);

    private final Model model;
    private final MainParser parser;
    private final AutoComplete autoComplete;

    public LogicManager(Model model) {
        this.model = model;
        this.parser = new MainParser();
        this.autoComplete = new AutoComplete(model);
    }

    @Override
    public CommandResult execute(String commandText) {
        logger.info("----------------[USER COMMAND][" + commandText + "]");
        Command command = parser.parse(commandText);
        command.setData(model);
        return command.execute();

    }
    
    @Override
    public ObservableList<ReadOnlyTask> getFilteredTaskList() {
        return model.getFilteredTaskList();
    }
    
    @Override
    public int getNumToday(){
        return model.getNumToday();
    }
    
    @Override
    public int getNumTmr(){
        return model.getNumTmr();
    }
    
    @Override
    public int getNumEvent(){
        return model.getNumEvent();
    }
    
    @Override
    public int getNumDeadline(){
        return model.getNumDeadline();
    }
    
    @Override
    public int getNumFloating(){
        return model.getNumFloating();
    }
    
    @Override
    public int getTotalNum(){
        return model.getTotalNum();
    }
    
    @Override
    public int getNumOverdue() {
        return model.getNumOverdue();
    }
}
```
###### \java\main\logic\parser\MainParser.java
``` java
package main.logic.parser;

import main.commons.core.EventsCenter;
import main.commons.core.LogsCenter;
import main.commons.core.Messages;
import main.commons.events.ui.updateListStatisticsPictureEvent;
import main.commons.exceptions.IllegalValueException;
import main.commons.exceptions.MultiplePriorityException;

import java.util.Date;
import java.util.List;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.commons.lang3.tuple.Pair;
import org.apache.commons.lang3.tuple.Triple;

import main.model.task.PriorityType;
import main.model.task.Task;
import main.model.task.TaskType;
import main.logic.command.AddCommand;
import main.logic.command.ClearCommand;
import main.logic.command.Command;
import main.logic.command.DeleteCommand;
import main.logic.command.DoneCommand;
import main.logic.command.EditCommand;
import main.logic.command.ExitCommand;
import main.logic.command.FindCommand;
import main.logic.command.HelpCommand;
import main.logic.command.IncorrectCommand;
import main.logic.command.ListCommand;
import main.logic.command.RedoCommand;
import main.logic.command.SortCommand;
import main.logic.command.StorageCommand;
import main.logic.command.UndoCommand;

public class MainParser {
    
    private static final Pattern BASIC_COMMAND_FORMAT = Pattern.compile("(?<commandWord>\\S+)(?<task>.*)");
    private static final Pattern EDIT_FORMAT = Pattern.compile("(?<index>\\d)(?<task>.*)");
    private static final Logger logger = LogsCenter.getLogger(MainParser.class);

    public MainParser() {}
    
    /***
     * parses the given input
     * 
     * @returns a Command object to be executed.
     */
    public Command parse(String input){
        final Matcher matcher = BASIC_COMMAND_FORMAT.matcher(input.trim());
        
        if (!matcher.matches()) {
            return commandIncorrectPlusHelp(Messages.MESSAGE_INVALID_COMMAND_FORMAT);
        }
        String commandWord = matcher.group("commandWord");
        String task = matcher.group("task");
        
        logger.fine("command word: " + commandWord);
        if (!ReferenceList.commandsDictionary.containsKey(commandWord.toLowerCase())) {
            return commandIncorrectPlusHelp(String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT, Messages.MESSAGE_UNKNOWN_COMMAND));
        }

        return getCommand(input, commandWord, task);
    }

    /***
     * Calls the appropriate prepare function according to the commandWord given.
     * 
     * @returns a Command object
     */
    private Command getCommand(String input, String commandWord, String task) {
        switch (ReferenceList.commandsDictionary.get(commandWord.toLowerCase())) {
            case AddCommand.COMMAND_WORD:
                return prepareAdd(task);
            case EditCommand.COMMAND_WORD:
                return prepareEdit(task);
            case DeleteCommand.COMMAND_WORD:
                return prepareDelete(task);
            case ListCommand.COMMAND_WORD:
                return prepareList(task);
            case HelpCommand.COMMAND_WORD:
                return new HelpCommand();
            case ExitCommand.COMMAND_WORD:
                return new ExitCommand();
            case DoneCommand.COMMAND_WORD:
                return prepareDone(task);
            case FindCommand.COMMAND_WORD:
                return new FindCommand();
            case ClearCommand.COMMAND_WORD:
                return new ClearCommand();
            case UndoCommand.COMMAND_WORD:
                return prepareUndo();
            case RedoCommand.COMMAND_WORD:
                return prepareRedo();
            case StorageCommand.COMMAND_WORD:
                return prepareStorage(input);
            case SortCommand.COMMAND_WORD:
                return prepareSort(task);
            default: 
                return commandIncorrectPlusHelp(String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT, Messages.MESSAGE_UNKNOWN_COMMAND));
        }
    }

    /**
     * @returns an IncorrectCommand object with help message
     */
    private Command commandIncorrectPlusHelp(String message) {
        return new IncorrectCommand(String.format(message, HelpCommand.MESSAGE_USAGE));
    }
    
    /**
     * Extracts task to be added from the given input 
     */    
    public Command prepareAdd(String task) {
        try {
            Task newTask = extractTask(task);
            return new AddCommand(newTask);
        } catch (MultiplePriorityException e) {
            return new IncorrectCommand(String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT, Messages.MESSAGE_MULTIPLE_PRIORITY));
        } catch (IllegalArgumentException e) {
            return new IncorrectCommand(String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT, Messages.MESSAGE_EMPTY_DESCRIPTION));
        }                      
    }     
    
    /**
     * Extracts relevant parameters for the EditCommamd, consisting of the index to be
     * replaced and Task to take its place. Appropriate IncorrectCommand when input
     * is invalid.
     */
    public Command prepareEdit(String input) {
        final Matcher edit_matcher = EDIT_FORMAT.matcher(input.trim());
        
        if (!edit_matcher.matches()) {
            return new IncorrectCommand(String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
        }
        
        int index;
        
        try {
            index = extractValidIndex(edit_matcher.group("index"));
        } catch (NumberFormatException e) {
            return new IncorrectCommand(String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE));
        } catch (IllegalValueException e) {
            return new IncorrectCommand(String.format(e.getMessage(), EditCommand.MESSAGE_USAGE));
        } 
                
        String task = edit_matcher.group("task");
      
        try {
            Task newTask = extractTask(task);
            return new EditCommand(index, newTask);
        } catch (IllegalArgumentException e) {
            return new IncorrectCommand(String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
        }  
    }
    
    /**
     * Extracts relevant parameters for the DeleteCommamd, and returns appropriate
     * IncorrectCommand when input is invalid
     */
    public Command prepareDelete(String input) {
        int index;
        
        try {
            index = extractValidIndex(input);
        } catch (NumberFormatException e) {
            return new IncorrectCommand(String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE));
        } catch (IllegalValueException e) {
            return new IncorrectCommand(String.format(e.getMessage(), DeleteCommand.MESSAGE_USAGE));
        } 
   
        return new DeleteCommand(index);
    }

    /**
     * Extracts relevant parameters for the DoneCommamd, and returns appropriate
     * IncorrectCommand when input is invalid
     */
    public Command prepareDone(String input) {
        int index;
        
        try {
            index = extractValidIndex(input);
        } catch (NumberFormatException e) {
            return new IncorrectCommand(String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT, DoneCommand.MESSAGE_USAGE));
        } catch (IllegalValueException e) {
            return new IncorrectCommand(String.format(e.getMessage(), DoneCommand.MESSAGE_USAGE));
        } 
   
        return new DoneCommand(index);
    }

    /**
     * Extracts a valid index from the given input. 
     *
     * @throws IllegalValueException when input is empty, or index derived is less than 0
     * @throws NumberFormatException if input given cannot be parsed as an integer.
     */
    private int extractValidIndex(String input) throws IllegalValueException, NumberFormatException{
        if (input.trim().equals(""))  {
            throw new IllegalValueException(Messages.MESSAGE_INVALID_COMMAND_FORMAT); 
        }
        
        int index = Integer.valueOf(input.trim()) - 1;
        
        if (index < 0) {
            throw new IllegalValueException(Messages.MESSAGE_INVALID_INDEX); 
        }

        return index;
    }
    
```
###### \java\main\logic\parser\MainParser.java
``` java
    /**
     * Extracts list parameters from the given input.
     * 
     * @returns appropriate ListCommand or IncorrectCommand if input is invalid.
     */
    public Command prepareList(String input) {
        if (input.trim().equals("")) {
            defaultListPicture();
            return new ListCommand();
        }
        
        Triple<String, List<Date>, List<Boolean>> info = TimeParser.extractTime(input.trim());

        String left = info.getLeft();
        List<Date> dates = info.getMiddle();
        PriorityType priority = null;
        TaskType type = null;
        boolean isDone = false;
        boolean onlyOverdue = false;
     
        for (String param: left.trim().split(" ")) {
            if (ReferenceList.priorityDictionary.containsKey(param) && priority == null) {
                priority = ReferenceList.priorityDictionary.get(param);
            }
            else if (ReferenceList.typeDictionary.containsKey(param) && type == null) {
                type = ReferenceList.typeDictionary.get(param);
            }
            else if (ReferenceList.doneSet.contains(param)) {
                isDone = true;
            }
            else if (param.equals(ReferenceList.overdue)) {
                onlyOverdue = true;
            }
            else if (!param.trim().equals("")) {
                return new IncorrectCommand(String.format(Messages.MESSAGE_INVALID_PARAMETERS,"ListCommand", ListCommand.MESSAGE_USAGE));
            }           
        }  
        
        Date date;
        date = getDate(dates);

        indicateListParamsChanged(priority, date, type, onlyOverdue);
        return new ListCommand(priority, date, type, isDone, onlyOverdue);
    }

    /**
     * Gets the first date if there are more than 1. If there are none, null is returned.
     * 
     * for prepareList function
     * 
     * @params list of dates given cannot be null
     */
    private Date getDate(List<Date> dates) {
        assert dates != null;
        
        Date date;
        if (dates.size() > 0) {
            date = dates.get(0);
        }
        else {
            date = null;
        }
        return date;
    }
    
    /**
     * Checks whether the input given matches the 2 sort parameter.
     * 
     * @returns SortCommand if input matches
     * @returns IncorrectCommand if input does not match
     */
    public Command prepareSort(String input) {
        String trimmed = input.trim().toLowerCase();
        
        if ("date".equals(trimmed) || "name".equals(trimmed)) {
            return new SortCommand(trimmed);
        }
        else {
            return new IncorrectCommand(String.format(Messages.MESSAGE_INVALID_PARAMETERS, "sort", SortCommand.MESSAGE_USAGE));
        }
    }

    /**
     * Checks whether task has a deadline, is an event, or is floating,
     * and uses the appropriate constructors accordingly.
     * 
     * @throws MultiplePriorityException if there are multiple priority indicated
     * @throws IllegalArgumentException if string input is invalid
     * @returns a Task object extracted from string given
     */
    private Task extractTask(String raw) throws MultiplePriorityException, IllegalArgumentException {

        Pair<PriorityType, String> proc = getPriority(raw.trim());
        PriorityType priority = proc.getKey();
        String input = proc.getValue();    
        
        Triple<String, List<Date>, List<Boolean>> info = TimeParser.extractTime(input.trim());
        List<Date> dates = info.getMiddle();
        String description = info.getLeft();
        Boolean isInferred = info.getRight().get(0);
        Boolean isRecurring = info.getRight().get(1);
                
        if (description.trim().equals("")) {
            throw new IllegalArgumentException();
        }
        else {
            description = removeConnectors(description);
        }
        
        if (dates.isEmpty()) {
            return (new Task(description, priority)).setIsInferred(isInferred).setIsRecurring(isRecurring);
        }
        else if (dates.size() == 1) { 
            return new Task(description,dates.get(0), priority).setIsInferred(isInferred).setIsRecurring(isRecurring);
        }
        // compare dates if there are 2 dates
        else {
            if (dates.get(0).before(dates.get(1)))
                return new Task(description,dates.get(0),dates.get(1), priority).setIsInferred(isInferred).setIsRecurring(isRecurring);
            else 
                return new Task(description,dates.get(1),dates.get(0), priority).setIsInferred(isInferred).setIsRecurring(isRecurring);
        }
    }
    
    /**
     * Removes unwanted connectors at the end. Connectors that are removed are found
     * in the connectSet in ReferenceList class.
     */
    private String removeConnectors(String description) {
        int end_index;
        
        for (String connector : ReferenceList.connectorSet) {
            if (connector.length() > description.length()) {
                continue;
            }
            
            end_index = description.length() - connector.length();
            if (argumentIndexInString(description, connector) == end_index) {
                return description.substring(0, end_index).trim();
            }
        }
        return description;
    }

    /**
     * Extracts the priority from the given input. Priority is indicated by the 
     * PriorityType enum class.
     * 
     * @throws MultiplePriorityException if multiple priority is detected.
     * @returns a pair consisting PriorityType and truncated message (without 
     * priority indicator).
     */
    private Pair<PriorityType,String> getPriority(String input) throws MultiplePriorityException{
        String [] levels = {"-h", "-m", "-l" };
        String [] enum_array = {"HIGH", "NORMAL", "LOW"};
        PriorityType priority = null;
        int index = input.length();
        int find;
        
        for (int i = 0; i < levels.length; i++) {
            if ((find = argumentIndexInString(input,levels[i])) != -1) {
                if (priority != null) {
                    throw new MultiplePriorityException();
                }
                priority = PriorityType.valueOf(enum_array[i]);
                index = find;
            }
        }

        if (priority == null) {
            priority = PriorityType.NORMAL;
        }
        
        String truncate = input.substring(0, index);
        
        return Pair.of(priority, truncate);
    }
    
    /**
     * @returns the last index at which arg given appears in str given
     */
    private int argumentIndexInString(String str, String arg) {
        return (str.toLowerCase().lastIndexOf(arg.toLowerCase()));
    }
    
    /**
     * Processes the list parameters and chooses one to be shown in the list statistics
     * by posting an event
     */
    private void indicateListParamsChanged(PriorityType priority, Date date, TaskType type, boolean onlyOverdue) {
        String paramToShow = "";
        if (onlyOverdue) {
            paramToShow = "overdue";
        }
        else if (priority != null) {
            paramToShow = priority.name();
        }
        else if (date != null) {
            paramToShow = "date";
        }
        else if (type != null) {
            paramToShow = type.name();
        }
        else {
            paramToShow = "list";
        }
            
        EventsCenter.getInstance().post(new updateListStatisticsPictureEvent(paramToShow));
    }
    
    /**
     * Changes the ListStatistics picture to the default one
     */
    private void defaultListPicture() {
        indicateListParamsChanged(null, null, null, false);
    }

    
}
```
###### \java\main\logic\parser\ReferenceList.java
``` java
package main.logic.parser;

import java.util.Map;
import java.util.Set;

import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;

import main.logic.command.*;
import main.model.task.PriorityType;
import main.model.task.TaskType;

public class ReferenceList {
    
    public static final Map<String,String> commandsDictionary = ImmutableMap.<String, String>builder()
            .put("add", AddCommand.COMMAND_WORD)
            .put("edit", EditCommand.COMMAND_WORD)
            .put("change", EditCommand.COMMAND_WORD)
            .put("delete", DeleteCommand.COMMAND_WORD)                        
            .put("remove", DeleteCommand.COMMAND_WORD)
            .put("rm", DeleteCommand.COMMAND_WORD)
            .put("trash", DeleteCommand.COMMAND_WORD)
            .put("done", DoneCommand.COMMAND_WORD)
            .put("finish", DoneCommand.COMMAND_WORD)
            .put("complete", DoneCommand.COMMAND_WORD)               
            .put("mark", DoneCommand.COMMAND_WORD)
            .put("undo", UndoCommand.COMMAND_WORD)
            .put("redo", RedoCommand.COMMAND_WORD)
            .put("exit", ExitCommand.COMMAND_WORD)
            .put("close", ExitCommand.COMMAND_WORD)
            .put("find", FindCommand.COMMAND_WORD)
            .put("search", FindCommand.COMMAND_WORD)
            .put("list", ListCommand.COMMAND_WORD)
            .put("show", ListCommand.COMMAND_WORD)
            .put("help", HelpCommand.COMMAND_WORD)
            .put("T.T", HelpCommand.COMMAND_WORD)
            .put("clear", ClearCommand.COMMAND_WORD)
            .put("storage", StorageCommand.COMMAND_WORD)
            .put("sort", SortCommand.COMMAND_WORD)
            .build(); 
    
    public static final Map<String,PriorityType> priorityDictionary = ImmutableMap.<String, PriorityType>builder()
            .put("high", PriorityType.HIGH)
            .put("impt", PriorityType.HIGH)
            .put("important", PriorityType.HIGH)
            .put("medium", PriorityType.NORMAL)
            .put("med", PriorityType.NORMAL)
            .put("normal", PriorityType.NORMAL)
            .put("low", PriorityType.LOW)
            .build();
    
    public static final Map<String,TaskType> typeDictionary = ImmutableMap.<String, TaskType>builder()
            .put("event", TaskType.EVENT)
            .put("events", TaskType.EVENT)
            .put("deadline", TaskType.DEADLINE)
            .put("deadlines", TaskType.DEADLINE)
            .put("floating", TaskType.FLOATING)
            .put("floatings", TaskType.FLOATING)
            .build();
    
    public static final String overdue = "overdue";
    
    //prepare list command
    public static final Set<String> doneSet = ImmutableSet.<String>builder()
            .add("done")
            .add("complete")
            .add("finish")
            .build();
    
    // connectors to be discarded
    public static final Set<String> connectorSet = ImmutableSet.<String>builder()
            .add("by")
            .add("from")
            .add("on")
            .add("due")
            .add("during")
            .add("at")
            .add("every")
            .build();
    
    // for autocomplete
    public static final Set<String> listSet = ImmutableSet.<String>builder()
            .add("high ")
            .add("low ")
            .add("normal ")
            .add("medium ")
            .add("event ")
            .add("deadline ")
            .add("floating ")
            .add("done ")
            .add("overdue ")
            .add("january ")
            .add("february ")
            .add("march ")
            .add("april ")
            .add("may ")
            .add("june ")
            .add("july ")
            .add("august ")
            .add("september ")
            .add("october ")
            .add("november ")
            .add("december ")
            .build();
    
    // for autocomplete
    public static final Set<String> sortSet = ImmutableSet.<String>builder()
            .add("name")
            .add("date")
            .build();
    
    // for autocomplete
    public static final Set<String> CommandsSetWithRelevantSpaces = ImmutableSet.<String>builder()
            .add(AddCommand.COMMAND_WORD + " ")
            .add(EditCommand.COMMAND_WORD + " ")
            .add(DeleteCommand.COMMAND_WORD + " ")
            .add(DoneCommand.COMMAND_WORD + " ")
            .add(UndoCommand.COMMAND_WORD)
            .add(RedoCommand.COMMAND_WORD)
            .add(ExitCommand.COMMAND_WORD)
            .add(FindCommand.COMMAND_WORD + " ")
            .add(ListCommand.COMMAND_WORD + " ")
            .add(HelpCommand.COMMAND_WORD)
            .add(ClearCommand.COMMAND_WORD)
            .add(StorageCommand.COMMAND_WORD + " ")
            .add(SortCommand.COMMAND_WORD + " ")
            .build();
}
```
###### \java\main\logic\parser\TimeParser.java
``` java
package main.logic.parser;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.logging.Logger;

import org.apache.commons.lang.StringUtils;
import org.apache.commons.lang3.tuple.Triple;

import com.google.common.collect.ImmutableList;
import com.joestelmach.natty.*;

import main.commons.core.LogsCenter;
import main.commons.util.DateUtil;


public class TimeParser {
    private static final Logger logger = LogsCenter.getLogger(TimeParser.class);
    
    Parser parser;
    
    public TimeParser() {
        parser = new Parser();
    }
    
    /*
     * extracts the relevant time information
     * 
     * @returns a triple of consisting of the task description, list of dates detected (max 2),
     * and list of boolean representing isTimeInferred and isRecurring.
     *  
     */
    public static Triple<String, List<Date>, List<Boolean>> extractTime(String raw_input) {
        List<DateGroup> groups = new Parser().parse(raw_input);
        
        if (groups.size() == 0) {
            return Triple.of(raw_input,new ArrayList<Date>(),ImmutableList.of(true,false));
        }

        DateGroup group = getLastGroup(groups);
        
        if(!isValidDate(raw_input, group)) {
            return Triple.of(raw_input, new ArrayList<Date>(), ImmutableList.of(true, false));
        }
                
        correctTime(group);

        List<Date> dates = group.getDates();
        boolean isInferred = group.isTimeInferred();
        
        if (isInferred) {
            setDefaultTime(dates);
        }

        String processed = getProcessedString(raw_input, group);      
        return Triple.of(processed.trim(),dates,ImmutableList.of(isInferred,group.isRecurring()));
    }

    /*
     * @returns the last DateGroup if there are multiple DateGroups
     */
    private static DateGroup getLastGroup(List<DateGroup> groups) {
        DateGroup group;
        if (groups.size() > 1) {
            group = groups.get(groups.size() - 1);
        }
        else {
            group = groups.get(0);
        }
        return group;
    }
    
    /*
     * checks whether a date is valid
     * 
     * date becomes invalid if suffix of date is not a whitespace, as this means
     * the date is likely to be part of another word.
     * 
     * @returns a boolean indicating the date's validity 
     */
    private static boolean isValidDate(String raw_input, DateGroup group) {
        if (dateAtExtremesOfInput(raw_input, group)) {
            return true;
        }
        else if (suffixOrPrefixNotWhitespace(group)) {
            logger.info("invalid date");
            return false;
        }
        else {
            return true;
        }
    }

    /*
     * checks if the immediate suffix or prefix are both not whitespaces 
     */
    private static boolean suffixOrPrefixNotWhitespace(DateGroup group) {
        return !Character.isWhitespace(group.getSuffix(1).charAt(0)) || !Character.isWhitespace(group.getPrefix(1).charAt(0));
    }

    /*
     * checks if group is at the start or end of the raw_input
     */
    private static boolean dateAtExtremesOfInput(String raw_input, DateGroup group) {
        return group.getPosition() == 1 || group.getPosition() + group.getText().length() - 1 == raw_input.length();
    }
    
    /*
     * corrects the time if need.
     * 
     * if time has no suffix (i.e pm or am), a reasonable time will be set,
     * i.e 4pm instead of 4am
     * 
     * @returns a DateGroup object with logical time
     */
    private static DateGroup correctTime(DateGroup group) {
        List<Date> dates = group.getDates();
        Map<String, List<ParseLocation>> parse_locations = group.getParseLocations();
        
        if (hasTimeWithoutMerdianIndicator(parse_locations)) {
            List<ParseLocation> hours = parse_locations.get("int_00_to_23_optional_prefix");
            
            for (int i = 0; i < hours.size() ; i++) {
                ParseLocation next = hours.get(i); 
                if (StringUtils.isNumeric(next.getText())) {
                    editDate(dates, i, next);
                }
            }
        }
        return group;
    }
    
    /*
     * replaces the original odd date with one that makes more logical sense
     */
    private static void editDate(List<Date> dates, int i, ParseLocation next) {
        logger.info("correcting time");                    
        int hour = Integer.valueOf(next.getText());
        hour = correctHour(hour);
        dates.set(i, DateUtil.setTime(dates.get(i), hour, false));
    }

    /*
     * checks if input has time information but no merdian indicator (i.e am, pm)
     */
    private static boolean hasTimeWithoutMerdianIndicator(Map<String, List<ParseLocation>> parse_locations) {
        return parse_locations.containsKey("int_00_to_23_optional_prefix") && !parse_locations.containsKey("simple_meridian_indicator");
    }

    /*
     * corrects odd timings, which appears because natty parser defaults 
     * unannotated numbers to morning. e.g 4 is 4am by default
     * 
     * @returns the new hour of the day
     */
    private static int correctHour(int hour) {
        if (hour < 7) {
            hour += 12;
        }
        else if (hour > 22) {
            hour -= 12;
        }
        return hour;
    }
    
    /*
     * set the time of given date to be 8am
     */
    private static Date setDefaultTime(Date date) {
        assert date != null;
        return DateUtil.setTime(date, 8, true);
    }
    
    /*
     * sets the list of dates' time to 8am
     */
    private static void setDefaultTime(List<Date> dates) {
        for (int i = 0; i < dates.size(); i++) {
            dates.set(i, setDefaultTime(dates.get(i)));
        }
    }

    /*
     * @returns string without the date inside
     */
    private static String getProcessedString(String input, DateGroup group) {

        StringBuilder builder = new StringBuilder();
        
        // natty indexing starts from 1
        builder.append(input.substring(0, group.getPosition() - 1).trim())
               .append(" ")
               .append(input.substring(group.getPosition() - 1 + group.getText().length(), input.length()).trim());
       
        return builder.toString();
    }
    
}

```
###### \java\main\model\filter\SortCriteria.java
``` java
package main.model.filter;

public enum SortCriteria {
    TIME, NAME
}
```
###### \java\main\model\filter\SortFilter.java
``` java
package main.model.filter;

import java.util.Comparator;
import main.model.task.Task;

public class SortFilter {
    

    //Sort by comparing deadlines and end date of events
    private Comparator<Task> byTime = (t1, t2) -> t1.compareTime(t2);

    //Sort lexicographically, case insensitive
    private Comparator<Task> byName = (t1, t2) -> t1.getMessage().toLowerCase().compareTo(t2.getMessage().toLowerCase());

    
    private Comparator<Task> sortCriteria;
    private boolean isReversed = false;
    
    public SortFilter(SortCriteria criteria) {
        switch (criteria) {
            case TIME:
                sortCriteria = byTime.thenComparing(byName);
                break;
            case NAME:
                sortCriteria = byName.thenComparing(byTime); 
                break;
            default:
                sortCriteria = byTime.thenComparing(byName);
                break;
        }
    }
    
    public Comparator<Task> getComparator() {
        if (isReversed) return sortCriteria.reversed();
        else return sortCriteria;
    }
    
    public void setReverse(boolean reverse) {
        isReversed = reverse;
    }
}
```
###### \java\main\model\Model.java
``` java
    /** Returns the filtered task list as an {@code UnmodifiableObservableList<ReadOnlyTask>} */
    UnmodifiableObservableList<ReadOnlyTask> getFilteredTaskList();

    /** Updates the filter of the filtered task list to show all pending tasks */
    void updateFilteredListToShowAllPending();

    /** Updates the filter of the filtered task list to show all completed tasks */    
    void updateFilteredListToShowAllDone();
    
    /** Returns the number of tasks today **/
    int getNumToday();

    /** Returns the number of tasks tomorrow **/
    int getNumTmr();
    
    /** Returns the total number of events in the list **/
    int getNumEvent();

    /** Returns the total number of tasks with deadline in the list **/
    int getNumDeadline();
    
    /** Returns the total number of floating tasks in the list **/
    int getNumFloating();

    /** Returns the total number of tasks in the list **/
    int getTotalNum();

    /** Updates the FilteredList based on criterias given **/
    void updateFilteredTaskList(Triple<PriorityType, Date, TaskType> params, boolean isDone, boolean onlyOverdue);

    /** Sorts the list based on criterias given **/
    void sortBy(SortCriteria criteria);

    /** THe default sorting done at the start **/
    void sortDefault();

    int getNumOverdue();

    void saveFilter();
    
    void revertFilter();

    void handleLoadTaskTrackerEvent(LoadTaskTrackerEvent event);

    void handleUpdateSuggestionsEvent(UpdateListWithSuggestionsEvent event);



	




    
}
```
###### \java\main\model\ModelManager.java
``` java
// adapted from addressbook level 4
package main.model;

import main.commons.core.ComponentManager;
import main.commons.core.EventsCenter;
import main.commons.core.LogsCenter;
import main.commons.core.UnmodifiableObservableList;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Stack;
import java.util.logging.Logger;

import org.apache.commons.lang3.tuple.Triple;

import com.google.common.collect.Lists;
import com.google.common.eventbus.Subscribe;

import javafx.collections.transformation.FilteredList;
import javafx.collections.transformation.SortedList;
import main.commons.events.model.ChangeSortFilterEvent;
import main.commons.events.model.LoadTaskTrackerEvent;
import main.commons.events.model.TaskTrackerChangedEvent;
import main.commons.events.model.UpdateListWithSuggestionsEvent;
import main.commons.util.DateUtil;

import main.logic.command.UndoCommand;
import main.model.TaskTracker;
import main.model.filter.SortCriteria;
import main.model.filter.SortFilter;
import main.model.task.PriorityType;
import main.model.task.ReadOnlyTask;
import main.model.task.Task;
import main.model.task.TaskType;
import main.model.task.UniqueTaskList.DuplicateTaskException;
import main.model.task.UniqueTaskList.TaskNotFoundException;

public class ModelManager extends ComponentManager implements Model {
    private static final Logger logger = LogsCenter.getLogger(ModelManager.class);
    
    public static Stack<UndoHistory> undoStack;
    public static Stack<UndoHistory> redoStack;
    
    private TaskTracker taskTracker;
    private final FilteredList<Task> filteredTasks;
    private final SortedList<Task> sortedTasks;
    private Expression baseExpression;
    private Expression save;
    
    public ModelManager(TaskTracker taskTracker, UserPrefs userPref) {
        super();
        assert taskTracker != null;
        assert userPref != null;

        logger.fine("Initializing with task tracker: " + taskTracker + " and user prefs " + userPref);
        EventsCenter.getInstance().registerHandler(this);
        
        this.taskTracker = new TaskTracker(taskTracker);
        filteredTasks = new FilteredList<>(this.taskTracker.getTasks());
        sortedTasks = new SortedList<>(this.filteredTasks);
        sortDefault();
        
        undoStack = new Stack<UndoHistory>();
        redoStack = new Stack<UndoHistory>();
    }
        
    public ModelManager() {
        this(new TaskTracker(), new UserPrefs());
    }

    @Override
    public void resetData(ReadOnlyTaskTracker newData) {
        if(newData.getTaskList().size()==0){
            List<ReadOnlyTask> prevTasks = taskTracker.getTaskList();
            addToUndoStack(UndoCommand.CLR, prevTasks.toArray(new Task [prevTasks.size()]));
        }
        taskTracker.resetData(newData);
        indicateTaskTrackerChanged();
    }
    
    public void setTasks(List<Task> tasks) {
        this.taskTracker.getUniqueTaskList().getInternalList().setAll(tasks);
}

    @Override
    public ReadOnlyTaskTracker getTaskTracker() {
        return taskTracker;
    }

    @Override
    public synchronized void deleteTask(int index) throws TaskNotFoundException {
        ReadOnlyTask target = getTaskfromIndex(index);
        taskTracker.removeTask(target);
        indicateTaskTrackerChanged();
        addToUndoStack(UndoCommand.DEL, (Task)target);
    }
    
    @Override
    public synchronized void doneTask(int index) throws TaskNotFoundException {
        ReadOnlyTask target = getTaskfromIndex(index);
        taskTracker.doneTask(target);
        indicateTaskTrackerChanged();
        addToUndoStack(UndoCommand.DONE,(Task)target);
    }
    
```
###### \java\main\model\ModelManager.java
``` java
    /** Raises an event to indicate the model has changed */
    private void indicateTaskTrackerChanged() {
        raise(new TaskTrackerChangedEvent(taskTracker));
}

    @Override
    public synchronized void addTask(Task task) throws DuplicateTaskException {
        taskTracker.addTask(task);
        updateFilteredListToShowAllPending();
        indicateTaskTrackerChanged();
        addToUndoStack(UndoCommand.ADD, task);
    }

    //================== Loading from storage =============================================
    @Override
    @Subscribe
    public void handleLoadTaskTrackerEvent(LoadTaskTrackerEvent event) {
        resetData(event.getTaskTracker());
    }
    
    //=========== Sorting ===================================================================
    @Override
    public void sortBy(SortCriteria criteria) {
        sortedTasks.setComparator(new SortFilter(criteria).getComparator());
    }
    
    @Override
    public void sortDefault() {
        sortBy(SortCriteria.TIME);
    }
    
    @Subscribe
    public void handleChangeSortFilterEvent(ChangeSortFilterEvent event) {
        sortBy(event.getSortCriteria());
    }
    
    //=========== User Friendly Accessors ===================================================================
    
    @Override
    public int getNumOverdue() {
        Expression original = baseExpression;
        updateFilteredTaskList(Triple.of(null, null, null), false, true);
        return getSizeAndReset(original);
    }
    
    @Override
    public int getNumToday() {
        Expression original = baseExpression;
        updateFilteredTaskList(Triple.of(null, DateUtil.getToday(), null), false, false);
        return getSizeAndReset(original);
    }
    
    @Override
    public int getNumTmr() {
        Expression original = baseExpression;
        updateFilteredTaskList(Triple.of(null, DateUtil.getTmr(), null), false, false);
        return getSizeAndReset(original);
    }
    
    @Override
    public int getNumEvent() {
        Expression original = baseExpression;
        updateFilteredTaskList(Triple.of(null, null, TaskType.EVENT), false, false);
        return getSizeAndReset(original);  
    }
    
    @Override
    public int getNumDeadline() {
        Expression original = baseExpression;
        updateFilteredTaskList(Triple.of(null, null, TaskType.DEADLINE), false, false);
        return getSizeAndReset(original);         
    }
    
    @Override
    public int getNumFloating() {
        Expression original = baseExpression;
        updateFilteredTaskList(Triple.of(null, null, TaskType.FLOATING), false, false);
        return getSizeAndReset(original); 
    }
    
    @Override 
    public int getTotalNum() {
        Expression original = baseExpression;
        updateFilteredListToShowAllPending();
        return getSizeAndReset(original);
    }

    private int getSizeAndReset(Expression original) {
        int num = filteredTasks.size();
        if (original == null) updateFilteredListToShowAllPending();
        else updateFilteredTaskList(original);
        return num;
    }
    

    //=========== Filtered Task List Accessors ===============================================================

    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getFilteredTaskList() {
        return new UnmodifiableObservableList<>(sortedTasks);        
    }

    @Override
    public void updateFilteredListToShowAllPending() {
        Expression filter = new PredicateExpression();
        filter.and(new DoneQualifier(false));
        
        updateFilteredTaskList(filter);
        baseExpression = filter;
    }
    
    @Override
    public void updateFilteredListToShowAllDone() {
        Expression filter = new PredicateExpression();
        filter.and(new DoneQualifier(true));
        
        updateFilteredTaskList(filter);
        baseExpression = filter;
    }
    
    
    @Override
    public void updateFilteredTaskList(Triple<PriorityType, Date, TaskType> params, boolean isDone, boolean onlyOverdue) {
        Expression filter = new PredicateExpression();
        
        filter.and(new DoneQualifier(isDone));
        
        if (params.getLeft() != null) {
            filter.and(new PriorityQualifier(params.getLeft()));
        }
        if (params.getMiddle() != null) {
            filter.and(new DateQualifier(params.getMiddle()));        
        }
        if (params.getRight() != null) {
            filter.and(new TypeQualifier(params.getRight()));
        }
        
        if (onlyOverdue) {
            filter.and(new OverdueQualifier());
        }
        
        updateFilteredTaskList(filter);
        baseExpression = filter;
    }
    
    public void updateFilteredTaskList(Expression expression) {
        baseExpression = expression;
        filteredTasks.setPredicate(expression::satisfies);
    }
    
    /*
     * saves a copy of the current filter. This filter is applied 
     * back when revertFilter() is called
     */
    @Override
    public void saveFilter() {
        save = baseExpression;
        logger.info("saved current filter");
    }
    
    /*
     * reverts filter to the one saved previous. If no copy was 
     * saved, the list is unchanged
     */
    @Override
    public void revertFilter() {
        if (save == null) {
            return;
        }
        baseExpression = save;
        updateFilteredTaskList(baseExpression);
        logger.info("reverted to saved filter");
    }
    
    //============= AutoComplete Suggestions ========================================
    
    @Override
    @Subscribe
    public void handleUpdateSuggestionsEvent(UpdateListWithSuggestionsEvent event) {
        List<ReadOnlyTask> suggestions = event.getSuggestions();

        Expression filter = new PredicateExpression();
        filter.and(new MatchQualifier(suggestions));
        updateFilteredTaskList(filter);
    }
    
    //========== Inner classes/interfaces used for filtering =================================================
    
    interface Expression {
        boolean satisfies(ReadOnlyTask task);
        void and(Qualifier qualifier);
        String toString();
    }

    private class PredicateExpression implements Expression {

        private List<Qualifier> qualifier = Lists.newArrayList();
        
        public PredicateExpression() {}
        
        @Override
        public void and(Qualifier qualifier) {
            this.qualifier.add(qualifier);
        }

        @Override
        public boolean satisfies(ReadOnlyTask task) {
            boolean qualify = true;
            
            for (Qualifier q : qualifier) {
                qualify = qualify && q.run(task); 
            }
            
            return qualify;
        }

        @Override
        public String toString() {
            return qualifier.toString();
        }
    }       

    interface Qualifier {
        boolean run(ReadOnlyTask task);
        String toString();
    }

    private class DateQualifier implements Qualifier {
        private Date date;

        DateQualifier(Date date) {
            this.date = date;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
//            return date.stream()
//                    .filter(keyword -> StringUtil.containsWordIgnoreCase(person.getName().fullName, keyword))
//                    .findAny()
//                    .isPresent();
//            return ((compareDate(date, task.getDeadline())) || (compareDate(date, task.getEndTime())) || (compareDate(date, task.getStartTime())));
            if (task.getIsEvent()) return DateUtil.dateOverlap(task.getStartTime(), task.getEndTime(), date);
            else if (!task.getIsFloating() && !task.getIsEvent()) return DateUtil.areSameDay(date, task.getDeadline()); 
            else return false;
        }


        @Override
        public String toString() {
            return ((new SimpleDateFormat("dd MMM")).format(this.date));
        }
    }
    
    private class TypeQualifier implements Qualifier {
        private TaskType type;

        TypeQualifier(TaskType type) {
            this.type = type;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            return task.getType() == type;
        }

        @Override
        public String toString() {
            return type.name();
        }
    }
    
    private class PriorityQualifier implements Qualifier {
        private PriorityType priority;

        PriorityQualifier(PriorityType priority) {
            this.priority = priority;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            return priority == task.getPriority();
        }

        @Override
        public String toString() {
            return priority.toString();
        }
    }
    
    private class DoneQualifier implements Qualifier {
        private boolean isDone;

        DoneQualifier(boolean isDone) {
            this.isDone = isDone;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            return isDone == task.getIsDone();
        }

        @Override
        public String toString() {
            return String.valueOf(isDone);
        }        
    }
    
    private class OverdueQualifier implements Qualifier {

        @Override
        public boolean run(ReadOnlyTask task) {
            return task.isOverdue();
        }

        @Override
        public String toString() {
            return "true";
        }        
    }

    private class MatchQualifier implements Qualifier {
        private List<ReadOnlyTask> matches;

        MatchQualifier(List<ReadOnlyTask> matches) {
            this.matches = matches;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            return matches.stream().filter(t -> t.equals(task)).findFirst().isPresent();
        }

        @Override
        public String toString() {
            return String.valueOf(matches);
        }        
        
    }
    
```
###### \java\main\storage\StorageManager.java
``` java
    @Override
    public void setTaskTrackerFilePath(String filepath) {
        assert FileUtil.isValidPath(filepath);
        taskTrackerStorage.setTaskTrackerFilePath(filepath);
    }
    
    /*
     * responds to FilePathChangedEvent.
     * 
     * If the new file path has original data, this data is loaded. Else, data will be
     * saved to the new file path. 
     */
    @Override
    @Subscribe
    public void handleFilePathChangedEvent(FilePathChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event, "Attempting to set and save to new file path"));

        String filePath = event.getFilePath();
        ReadOnlyTaskTracker taskTracker = event.getTaskTracker();
        
        setTaskTrackerFilePath(filePath);

        ReadOnlyTaskTracker originalData = originalData();
        if (originalData != null) {
            taskTracker = originalData;
        }
        else {
            saveTaskTracker(filePath, taskTracker);  
        }
        
        logger.info(taskTracker.getTaskList().size() + "");
        saveConfig(filePath);
        
        EventsCenter.getInstance().post(new LoadTaskTrackerEvent(taskTracker));
        
    }

    private void saveTaskTracker(String filePath, ReadOnlyTaskTracker taskTracker) {
        try {
            saveTaskTracker(taskTracker);
        } catch (IOException e) {
            logger.warning("Problem writing to file");
        }
    }
    
    private void saveConfig(String filePath) {
        try {
            ConfigUtil.saveConfig(new Config(filePath), Config.DEFAULT_CONFIG_FILE);
        } catch (IOException e) {
            logger.warning("Failed to save config file : " + StringUtil.getDetails(e));
        }        
    }
    
    private ReadOnlyTaskTracker originalData() {
        Optional<ReadOnlyTaskTracker> taskTrackerOptional;

        try {
            taskTrackerOptional = readTaskTracker();
            
            logFileDetails(taskTrackerOptional);
            
            return taskTrackerOptional.orElse(null);
        } catch (DataConversionException e) {
            logger.warning("Data file not in the correct format. Overwriting file with current data");
            return null;
        } catch (IOException e) {
            logger.warning("Problem while reading from the file. Prompt for new location");
            return null;
        }
    }

    private void logFileDetails(Optional<ReadOnlyTaskTracker> taskTrackerOptional) {
        if (taskTrackerOptional.isPresent()) {
            logger.info("File already has data. Loading original data");
        }
        else {
            logger.info("Saving to new file path");
        }
    }

}
```
###### \java\main\ui\CommandBox.java
``` java
    @Subscribe
    public void handleFilePathChangedEvent(FilePathChangedEvent event) {
        StatusBarFooter.updateSaveLocation(event.getFilePath());
    }
    
	@FXML
	public void handleKeyReleased(KeyEvent event) {
		if (!keysThatChangeCommandInput(event))
			return;
		String input = commandTextField.getText();
		EventsCenter.getInstance().post(new KeyPressEvent(input));
	}

    private boolean keysThatChangeCommandInput(KeyEvent event) {
        return event.getCode().isDigitKey() || event.getCode().isLetterKey() || event.getCode() == KeyCode.BACK_SPACE
				|| event.getCode() == KeyCode.DELETE;
    }

	public void handleTabEvent() {
		commandTextField.addEventFilter(KeyEvent.KEY_PRESSED, (KeyEvent event) -> {
			if (event.getCode() == KeyCode.TAB) {
				EventsCenter.getInstance().post(new TabPressEvent());
				event.consume();
			}
		});
	}

	@Subscribe
	public void handleAutoComplete(AutoCompleteEvent event) {
		commandTextField.replaceText(event.getStart(), event.getEnd(), event.getSuggestion());
	}

```
