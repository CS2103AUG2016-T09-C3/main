# A0144132W
###### /java/main/ui/CommandBox.java
``` java
    @FXML
    public void handleKeyReleased(KeyEvent event) {
        if (!event.getCode().isDigitKey() && !event.getCode().isLetterKey() && event.getCode() != KeyCode.BACK_SPACE
                && event.getCode() != KeyCode.DELETE)
            return;
        String input = commandTextField.getText();
        EventsCenter.getInstance().post(new KeyPressEvent(event.getCode(), input));
    }

    public void handleTabEvent() {
        commandTextField.addEventFilter(KeyEvent.KEY_PRESSED, (KeyEvent event) -> {
            if (event.getCode() == KeyCode.TAB) {
                EventsCenter.getInstance().post(new TabPressEvent(event.getCode()));
                event.consume();
            }
        });
    }

    @Subscribe
    public void handleAutoComplete(AutoCompleteEvent event) {
        commandTextField.replaceText(event.getStart(), event.getEnd(), event.getSuggestion());
    }

}
```
###### /java/main/logic/command/ListCommand.java
``` java
package main.logic.command;

import java.util.Date;
import org.apache.commons.lang3.tuple.Triple;

import main.commons.util.DateUtil;
import main.model.task.PriorityType;
import main.model.task.TaskType;

/**
 * Lists certain tasks in the task tracker to the user.
 */

public class ListCommand extends Command {
    
    public static final String COMMAND_WORD = "list";
    public static final String MESSAGE_USAGE = COMMAND_WORD 
            + "Parameters: [priority] [date] [type] \n"
            + "All parameters optional and interchangeable \n"
            + "Eg: " + COMMAND_WORD + " high today";
    public static final String MESSAGE_SUCCESS = "Listed all %1$s";
    
    private PriorityType priority;
    private Date date;
    private TaskType type;
    private boolean isDefault = false;
    private boolean isDone = false;
    
    public ListCommand() {
        isDefault = true;
    }
      
    public ListCommand(Triple<PriorityType, Date, TaskType> parameters, boolean isDone) {
        priority = parameters.getLeft();
        date = parameters.getMiddle();
        type = parameters.getRight();
        this.isDone = isDone;
    }

	@Override
	public CommandResult execute() {

	    if (isDefault) model.updateFilteredListToShowAllPending();
	    else model.updateFilteredTaskList(Triple.of(priority, date, type), isDone);
	    
	    return new CommandResult(String.format(MESSAGE_SUCCESS, getReadableCriteria()));    
	}
	
	private String getReadableCriteria() {
	    StringBuilder readable = new StringBuilder();
	 
	    String prefix;
	    if (isDone) prefix = "completed";
	    else prefix = "pending";
	    
	    String task;
	    if (type == null) task = "tasks";
	    else if (type == TaskType.EVENT) task = "events";
        else if (type == TaskType.DEADLINE) task = "tasks with deadlines";
        else task = "floating tasks";
	    
	    if (priority == null) readable.append(prefix).append(" ").append(task);
	    else if (priority == PriorityType.LOW) readable.append(prefix).append(" low priority ").append(task);
	    else if (priority == PriorityType.HIGH) readable.append(prefix).append(" high priority ").append(task);
	    else readable.append(prefix).append(" normal priority ").append(task);

	    if (date != null) readable.append(" due ").append(DateUtil.readableDate(date, true));
	    
	    return readable.toString();
	    
	}
}
```
###### /java/main/logic/command/SortCommand.java
``` java
package main.logic.command;

import main.commons.core.EventsCenter;
import main.commons.core.Messages;
import main.commons.events.model.ChangeSortFilterEvent;

public class SortCommand extends Command {
    
    public static final String COMMAND_WORD = "sort";
    public static final String MESSAGE_USAGE = COMMAND_WORD 
            + "Parameters: <date | name> \n"
            + "Parameter can only be 'date' or 'name' \n"
            + "Eg: " + COMMAND_WORD + " date";
    public static final String MESSAGE_SUCCESS = "Sorting by %1$s";
    
    private String param;
    public SortCommand(String param) {
        this.param = param;
    }

    @Override
    public CommandResult execute() {
        assert (param.equals("date") || param.equals("name"));

        EventsCenter.getInstance().post(new ChangeSortFilterEvent(param));
        return new CommandResult(String.format(MESSAGE_SUCCESS, param));
    }
    

}
```
###### /java/main/logic/command/FindCommand.java
``` java
package main.logic.command;

public class FindCommand extends Command {
    
    public static final String COMMAND_WORD = "find";
    public static final String MESSAGE_USAGE = COMMAND_WORD 
            + "Parameters: [keywords] \n"
            + "Type in keywords found in the desired task's description \n"
            + "Eg: " + COMMAND_WORD + " cs2103";
    public static final String MESSAGE_SUCCESS = "Found %1$s matching tasks";
    
    public FindCommand() {}
    
    @Override
    public CommandResult execute() {
        return new CommandResult(String.format(MESSAGE_SUCCESS, model.getFilteredTaskList().size()));
    }
    
}
```
###### /java/main/logic/command/ClearCommand.java
``` java
package main.logic.command;

import main.model.ReadOnlyTaskTracker;
import main.model.TaskTracker;
import main.model.task.UniqueTaskList;
import main.ui.ListStatistics;

public class ClearCommand extends Command {
    
    public static final String COMMAND_WORD = "clear";
    public static final String MESSAGE_USAGE = COMMAND_WORD;
    public static final String MESSAGE_SUCCESS = "Task-Tracker has been cleared!";
    
    public ClearCommand() {}

    @Override
    public CommandResult execute() {
        model.resetData((ReadOnlyTaskTracker) new TaskTracker(new UniqueTaskList()));
        return new CommandResult(MESSAGE_SUCCESS);
    }
}
```
###### /java/main/logic/Logic.java
``` java
// adapted from addressbook level 4
package main.logic;

import javafx.collections.ObservableList;
import main.logic.command.CommandResult;
import main.model.task.ReadOnlyTask;

public interface Logic {
    
    /**
     * Executes the command and returns the result.
     * @param commandText The command as entered by the user.
     * @return the result of the command execution.
     */
    public CommandResult execute(String input);
    
    /** Returns the filtered list of persons */
    ObservableList<ReadOnlyTask> getFilteredTaskList();

    /** Returns the number of tasks due or happening today **/
    int getNumToday();

    /** Returns the number of tasks due or happening the next day **/
    int getNumTmr();
    
    /** Returns the number of events in the list **/
    int getNumEvent();

    /** Returns the number of tasks with deadline in the list **/
    int getNumDeadline();
    
    /** Returns the number of floating tasks in the list **/    
    int getNumFloating();

    int getTotalNum();

}
```
###### /java/main/logic/parser/ReferenceList.java
``` java
package main.logic.parser;

import java.util.Map;
import java.util.Set;

import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;

import main.logic.command.*;
import main.model.task.PriorityType;
import main.model.task.TaskType;

public class ReferenceList {
    
    public static final Map<String,String> commandsDictionary = ImmutableMap.<String, String>builder()
            .put("add", AddCommand.COMMAND_WORD)
            .put("edit", EditCommand.COMMAND_WORD)
            .put("change", EditCommand.COMMAND_WORD)
            .put("delete", DeleteCommand.COMMAND_WORD)                        
            .put("remove", DeleteCommand.COMMAND_WORD)
            .put("rm", DeleteCommand.COMMAND_WORD)
            .put("trash", DeleteCommand.COMMAND_WORD)
            .put("done", DoneCommand.COMMAND_WORD)
            .put("finish", DoneCommand.COMMAND_WORD)
            .put("complete", DoneCommand.COMMAND_WORD)               
            .put("mark", DoneCommand.COMMAND_WORD)
            .put("undo", UndoCommand.COMMAND_WORD)
            .put("redo", RedoCommand.COMMAND_WORD)
            .put("exit", ExitCommand.COMMAND_WORD)
            .put("close", ExitCommand.COMMAND_WORD)
            .put("find","find")
            .put("search","find")
            .put("list", ListCommand.COMMAND_WORD)
            .put("show", ListCommand.COMMAND_WORD)
            .put("help", HelpCommand.COMMAND_WORD)
            .put("T.T", HelpCommand.COMMAND_WORD)
            .put("clear", ClearCommand.COMMAND_WORD)
            .put("storage", StorageCommand.COMMAND_WORD)
            .put("sort", SortCommand.COMMAND_WORD)
            .build(); 
    
    public static final Map<String,PriorityType> priorityDictionary = ImmutableMap.<String, PriorityType>builder()
            .put("high", PriorityType.HIGH)
            .put("impt", PriorityType.HIGH)
            .put("important", PriorityType.HIGH)
            .put("medium", PriorityType.NORMAL)
            .put("med", PriorityType.NORMAL)
            .put("normal", PriorityType.NORMAL)
            .put("low", PriorityType.LOW)
            .build();
    
    public static final Map<String,TaskType> typeDictionary = ImmutableMap.<String, TaskType>builder()
            .put("event", TaskType.EVENT)
            .put("events", TaskType.EVENT)
            .put("deadline", TaskType.DEADLINE)
            .put("deadlines", TaskType.DEADLINE)
            .put("floating", TaskType.FLOATING)
            .put("floatings", TaskType.FLOATING)
            .build();
    
    // for autocomplete and prepare list command
    public static final Set<String> doneSet = ImmutableSet.<String>builder()
            .add("done")
            .add("complete")
            .add("finish")
            .build();
    
    // for autocomplete
    public static final Set<String> listSet = ImmutableSet.<String>builder()
            .add("high")
            .add("low")
            .add("normal")
            .add("medium")
            .add("event")
            .add("deadline")
            .add("floating")
            .add("january")
            .add("february")
            .add("march")
            .add("april")
            .add("may")
            .add("june")
            .add("july")
            .add("august")
            .add("september")
            .add("october")
            .add("november")
            .add("december")
            .build();
            
}
```
###### /java/main/logic/parser/TimeParser.java
``` java
package main.logic.parser;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.logging.Logger;

import org.apache.commons.lang.StringUtils;
import org.apache.commons.lang3.tuple.Triple;

import com.google.common.collect.ImmutableList;
import com.joestelmach.natty.*;

import main.commons.core.LogsCenter;
import main.commons.util.DateUtil;


public class TimeParser {
    private static final Logger logger = LogsCenter.getLogger(TimeParser.class);

    
    Parser parser = new Parser();
    
    public TimeParser() {}
    
    /*
     * extracts the relevant time information
     * 
     * @returns a triple of consisting of the task description, list of dates detected (max 2),
     * and list of boolean representing isTimeInferred and isRecurring.
     *  
     */
    public static Triple<String, List<Date>, List<Boolean>> extractTime(String raw_input) {
        List<DateGroup> groups = new Parser().parse(raw_input);
        
        if (groups.size() == 0) {
            return Triple.of(raw_input,new ArrayList<Date>(),ImmutableList.of(true,false));
        }

        DateGroup group = groups.get(0);
        
        if(!isValidDate(raw_input, group)) return Triple.of(raw_input, new ArrayList<Date>(), ImmutableList.of(true, false));
                
        correctTime(group);

        List<Date> dates = group.getDates();
        
        boolean isInferred = group.isTimeInferred();
        
        if (isInferred) {
            for (int i = 0; i < dates.size(); i++) {
                dates.set(i, setDefaultTime(dates.get(i)));
            }
        }
        
        String processed = getProcessedString(raw_input, group);
        
        return Triple.of(processed.trim(),dates,ImmutableList.of(isInferred,group.isRecurring()));
    }

    private static boolean isValidDate(String raw_input, DateGroup group) {
        // if suffix of date is not a whitespace. Most likely incorrectly parsed
        try {
            if (!Character.isWhitespace(group.getSuffix(1).charAt(0))) {
                logger.info("invalid date");
                return false;
            }
        } catch (StringIndexOutOfBoundsException e) {
            return true; // happens when the date is at the start of the string
        } 
        return true;
    }
    
    /*
     * corrects odd timings
     * 
     * natty parser defaults unannotated numbers to morning
     * e.g 4 is 4am by default
     * 
     * if time has no postfix (i.e pm or am), set a reasonable time, i.e 4pm instead of 4am
     * 
     */
    private static void correctTime(DateGroup group) {
        List<Date> dates = group.getDates();
        Map<String, List<ParseLocation>> parse_locations = group.getParseLocations();
        
        // maximum number of dates is 2
        if (dates.size() > 2) dates = dates.subList(0, 2);
        
        if (parse_locations.containsKey("int_00_to_23_optional_prefix") && !parse_locations.containsKey("simple_meridian_indicator")) {
            List<ParseLocation> hours = parse_locations.get("int_00_to_23_optional_prefix");
            
            for (int i = 0; i < hours.size() ; i++) {
                ParseLocation next = hours.get(i); 
                if (StringUtils.isNumeric(next.getText())) {
                    logger.info("correcting time");
                    
                    int hour = Integer.valueOf(next.getText());
                    if (hour < 7) hour += 12;
                    else if (hour > 22) hour -= 12;
                    
                    dates.set(i, DateUtil.setTime(dates.get(i), hour, false));
                }
            }
        }
    }
    
    private static Date setDefaultTime(Date date) {
        assert date != null;
        return DateUtil.setTime(date, 8, true);
    }


    
    private static String getProcessedString(String input, DateGroup group) {

        StringBuilder builder = new StringBuilder();
        
        // natty indexing starts from 1
        builder.append(input.substring(0, group.getPosition() - 1).trim())
               .append(" ")
               .append(input.substring(group.getPosition() - 1 + group.getText().length(), input.length()).trim());
       
        return builder.toString();
    }
    
}

```
###### /java/main/logic/parser/MainParser.java
``` java
package main.logic.parser;

import main.commons.core.EventsCenter;
import main.commons.core.LogsCenter;
import main.commons.core.Messages;
import main.commons.events.ui.updateListStatisticsPictureEvent;
import main.commons.exceptions.IllegalValueException;
import main.commons.exceptions.MultiplePriorityException;

import java.util.Date;
import java.util.List;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.commons.lang3.tuple.Pair;
import org.apache.commons.lang3.tuple.Triple;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableList.Builder;

import main.model.task.PriorityType;
import main.model.task.Task;
import main.model.task.TaskType;
import main.logic.command.AddCommand;
import main.logic.command.ClearCommand;
import main.logic.command.Command;
import main.logic.command.DeleteCommand;
import main.logic.command.DoneCommand;
import main.logic.command.EditCommand;
import main.logic.command.ExitCommand;
import main.logic.command.FindCommand;
import main.logic.command.HelpCommand;
import main.logic.command.IncorrectCommand;
import main.logic.command.ListCommand;
import main.logic.command.RedoCommand;
import main.logic.command.SortCommand;
import main.logic.command.StorageCommand;
import main.logic.command.UndoCommand;

public class MainParser {
    
    private static final Pattern BASIC_COMMAND_FORMAT = Pattern.compile("(?<commandWord>\\S+)(?<task>.*)");
    private static final Pattern EDIT_FORMAT = Pattern.compile("(?<index>\\d)(?<task>.*)");
    private static final Logger logger = LogsCenter.getLogger(MainParser.class);

       
    public MainParser() {}
    
    public Command parse(String input){
        
        final Matcher matcher = BASIC_COMMAND_FORMAT.matcher(input.trim());
        
        if (!matcher.matches()) {
            return commandIncorrect(Messages.MESSAGE_INVALID_COMMAND_FORMAT);
        }
        String commandWord = matcher.group("commandWord");
        String task = matcher.group("task");
        
        logger.fine("command word: " + commandWord);

        if (!ReferenceList.commandsDictionary.containsKey(commandWord.toLowerCase())) {
            return commandIncorrect(String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT, Messages.MESSAGE_UNKNOWN_COMMAND));
        }

        return getCommand(input, commandWord, task);
           
    }

    private Command getCommand(String input, String commandWord, String task) {
        switch (ReferenceList.commandsDictionary.get(commandWord.toLowerCase())) {
            case AddCommand.COMMAND_WORD:
                return prepareAdd(task);
            case EditCommand.COMMAND_WORD:
                return prepareEdit(task);
            case DeleteCommand.COMMAND_WORD:
                return prepareDelete(task);
            case ListCommand.COMMAND_WORD:
                return prepareList(task);
            case HelpCommand.COMMAND_WORD:
                return new HelpCommand();
            case ExitCommand.COMMAND_WORD:
                return new ExitCommand();
            case DoneCommand.COMMAND_WORD:
                return prepareDone(task);
            case FindCommand.COMMAND_WORD:
                return new FindCommand();
            case ClearCommand.COMMAND_WORD:
                return new ClearCommand();
            case UndoCommand.COMMAND_WORD:
                return prepareUndo();
            case RedoCommand.COMMAND_WORD:
                return prepareRedo();
            case StorageCommand.COMMAND_WORD:
                return prepareStorage(input);
            case SortCommand.COMMAND_WORD:
                return prepareSort(task);
            default: 
                return commandIncorrect(String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT, Messages.MESSAGE_UNKNOWN_COMMAND));
        }
    }

    private Command commandIncorrect(String message) {
        return new IncorrectCommand(String.format(message, HelpCommand.MESSAGE_USAGE));
    }
    
    /*
     * checks whether task has a deadline, is an event, or is floating,
     * and uses the appropriate constructors accordingly.
     * 
     * @return an AddCommand Object
     */    
    public Command prepareAdd(String task) {
        try {
            Task newTask = extractTask(task);
            return new AddCommand(newTask);
        } catch (MultiplePriorityException e) {
            return new IncorrectCommand(String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT, Messages.MESSAGE_MULTIPLE_PRIORITY));
        } catch (IllegalArgumentException e) {
            return new IncorrectCommand(String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT, Messages.MESSAGE_EMPTY_DESCRIPTION));
        }                      
    }     
    
    public Command prepareEdit(String input) {
        final Matcher edit_matcher = EDIT_FORMAT.matcher(input.trim());
        
        if (!edit_matcher.matches()) {
            return new IncorrectCommand(String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
        }
        
        int index = Integer.valueOf(edit_matcher.group("index")) - 1;
                
        String task = edit_matcher.group("task");
      
        try {
            Task newTask = extractTask(task);
            return new EditCommand(index, newTask);
        } catch (IllegalArgumentException e) {
            return new IncorrectCommand(String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
        }  
    }
    
    public Command prepareDelete(String input) {
        int index;
        
        try {
            index = extractValidIndex(input);
        } catch (NumberFormatException e) {
            return new IncorrectCommand(String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE));
        } catch (IllegalValueException e) {
            return new IncorrectCommand(String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT, e.getMessage()));
        } 
   
        return new DeleteCommand(index);
    }

    
    public Command prepareDone(String input) {
        int index;
        
        try {
            index = extractValidIndex(input);
        } catch (NumberFormatException e) {
            return new IncorrectCommand(String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT, DoneCommand.MESSAGE_USAGE));
        } catch (IllegalValueException e) {
            return new IncorrectCommand(String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT, e.getMessage()));
        } 
   
        return new DoneCommand(index);
    }

    private int extractValidIndex(String input) throws IllegalValueException, NumberFormatException{
        if (input.trim() == "") throw new IllegalValueException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX); 
        
        int index;
        
        index = Integer.valueOf(input.trim()) - 1;

        return index;
    }
    
```
###### /java/main/logic/parser/MainParser.java
``` java
    public Command prepareList(String input) {
        if (input.trim().equals("")) return new ListCommand();
        
        Triple<String, List<Date>, List<Boolean>> info = TimeParser.extractTime(input.trim());

        String left = info.getLeft();
        List<Date> dates = info.getMiddle();
        PriorityType priority = null;
        TaskType type = null;
        boolean isDone = false;
     
        for (String param: left.trim().split(" ")) {
            if (ReferenceList.priorityDictionary.containsKey(param) && priority == null) {
                priority = ReferenceList.priorityDictionary.get(param);
            }
            else if (ReferenceList.typeDictionary.containsKey(param) && type == null) {
                type = ReferenceList.typeDictionary.get(param);
            }
            else if (ReferenceList.doneSet.contains(param)) {
                isDone = true;
            }
            
            else if (!param.trim().equals("")) {
                return new IncorrectCommand(String.format(Messages.MESSAGE_INVALID_PARAMETERS,"ListCommand", ListCommand.MESSAGE_USAGE));
            }           
        }  
        
        Date date;
        if (dates.size() > 0) {
            date = dates.get(0);
        }
        else {
            date = null;
        }

        indicateListParamsChanged(Triple.of(priority, date, type));
        return new ListCommand(Triple.of(priority, date, type), isDone);
    }
    
    public Command prepareSort(String input) {
        input = input.trim().toLowerCase();
        
        if (input.equals("date") || input.equals("name")) {
            return new SortCommand(input);
        }
        else {
            return new IncorrectCommand(String.format(Messages.MESSAGE_INVALID_PARAMETERS, "sort", SortCommand.MESSAGE_USAGE));
        }
    }

    private Task extractTask(String raw) throws MultiplePriorityException, IllegalArgumentException {

        Pair<PriorityType, String> proc = getPriority(raw.trim());
        PriorityType priority = proc.getKey();
        String input = proc.getValue();    
        
        Triple<String, List<Date>, List<Boolean>> info = TimeParser.extractTime(input.trim());
        List<Date> dates = info.getMiddle();
        String description = info.getLeft();
        Boolean isInferred = info.getRight().get(0);
        Boolean isRecurring = info.getRight().get(1);
        
        if (description.trim().equals("")) {
            throw new IllegalArgumentException();
        }
        
        if (dates.isEmpty()) {
            return (new Task(description, priority)).setIsInferred(isInferred).setIsRecurring(isRecurring);
        }
        else if (dates.size() == 1) { 
            return new Task(description,dates.get(0), priority).setIsInferred(isInferred).setIsRecurring(isRecurring);
        }
        // compare dates if there are 2 dates
        else {
            if (dates.get(0).before(dates.get(1)))
                return new Task(description,dates.get(0),dates.get(1), priority).setIsInferred(isInferred).setIsRecurring(isRecurring);
            else 
                return new Task(description,dates.get(1),dates.get(0), priority).setIsInferred(isInferred).setIsRecurring(isRecurring);
        }
    }
    
    /*
     * uses PriorityType enum class
     * 
     * @return a pair consisting PriorityType and truncated message (without priority indicator)
     */
    private Pair<PriorityType,String> getPriority(String input) throws MultiplePriorityException{
        String [] levels = {"-h", "-m", "-l" };
        int priority = 0;
        int index = input.length();
        int find;
        
        for (int i = 0; i < levels.length; i++) {
            if ((find = argumentIndexInString(input,levels[i])) != -1) {
                if (priority != 0) {
                    throw new MultiplePriorityException();
                }
                priority = i+1;
                index = find;
            }
        }

        if (priority == 0) {
            priority = 2;
        }
        
        PriorityType priority_enum;
        
        if (priority == 1) {
            priority_enum = PriorityType.HIGH;
        }
        else if (priority == 2) {
            priority_enum = PriorityType.NORMAL;
        }
        else {
            priority_enum = PriorityType.LOW;
        }
        
        input = input.substring(0, index);
        logger.info(input + " priority " + priority_enum);
        
        return Pair.of(priority_enum,input);
    }
    
    private int argumentIndexInString(String str, String arg) {
        return (str.toLowerCase().lastIndexOf(arg.toLowerCase()));
    }
    
    /*
     * processes the list parameters and chooses one to be shown in the list statistics
     * by posting an event
     */
    private void indicateListParamsChanged(Triple<PriorityType, Date, TaskType> params) {
        String paramToShow = "";
        if (params.getLeft() != null) {
            paramToShow = params.getLeft().name();
        }
        else if (params.getMiddle() != null) {
            paramToShow = "date";
        }
        else if (params.getRight() != null) {
            paramToShow = params.getRight().name();
        }
        else {
            paramToShow = "list";
        }
            
        EventsCenter.getInstance().post(new updateListStatisticsPictureEvent(paramToShow));
    }
    
}
```
###### /java/main/logic/autocomplete/SetTrie.java
``` java
package main.logic.autocomplete;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;

// Referenced from http://sujitpal.blogspot.sg/2007/02/three-autocomplete-implementations.html
public class SetTrie {

    private TreeSet<String> wordList;
    private boolean caseInsensitive; 
    

    public SetTrie(TreeSet<String> wordList, boolean caseInsensitive) {
        this.wordList = wordList;
        this.caseInsensitive = caseInsensitive;
        if (caseInsensitive) this.wordList.stream().map(String::toLowerCase); 
    }
   
    public boolean matchPrefix(String prefix) {
        if (caseInsensitive) prefix = prefix.toLowerCase();

        Set<String> tailSet = wordList.tailSet(prefix);
        for (String tail : tailSet) {
            if (tail.startsWith(prefix)) {
                return true;
            }
        }
        return false;
    }
    
    public List<String> getSuggestions(String prefix) {
        if (caseInsensitive) prefix = prefix.toLowerCase();

        List<String> possibleList = new ArrayList<String>();
        Set<String> tailSet = wordList.tailSet(prefix);
        for (String tail : tailSet) {
            if (tail.startsWith(prefix)) {
                possibleList.add(tail);
            } 
            else {
                break;
            }
        }
        return possibleList;
    }
    
    @Override
    public String toString(){
        StringBuilder stringBuilder = new StringBuilder();
        
        for (String word : wordList) {
            stringBuilder.append(word).append(" ");
        }
        return stringBuilder.toString().trim();
    }
    
    public static TrieBuilder builder() {
        return new TrieBuilder();
    }
    
    public static TrieBuilder builder(SetTrie trie) {
        return new TrieBuilder(trie);
    }
    
    public static class TrieBuilder {
        
        private TreeSet<String> wordList;
        private boolean caseInsensitive = false;
        
        private TrieBuilder() {
            wordList = new TreeSet<String>();
        }
        
        private TrieBuilder(SetTrie trie) {
            trie.wordList = new TreeSet<String>();
        }
        
        
        public TrieBuilder caseInsensitive() {
            this.caseInsensitive = true;
            return this;
        }
        
        public TrieBuilder add(Collection<String> words) {
            wordList.addAll(words);
            return this;
        }
        
        public SetTrie build() {
            return new SetTrie(wordList, caseInsensitive);
        }        
    }
}
```
###### /java/main/logic/autocomplete/AutoComplete.java
``` java
package main.logic.autocomplete;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.logging.Logger;
import java.util.stream.Collectors;

import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.StringUtils;

import com.google.common.eventbus.Subscribe;

import org.apache.commons.lang3.tuple.Pair;
import main.commons.core.EventsCenter;
import main.commons.core.LogsCenter;
import main.commons.events.model.TaskTrackerChangedEvent;
import main.commons.events.model.UpdateListWithSuggestionsEvent;
import main.commons.events.ui.AutoCompleteEvent;
import main.commons.events.ui.KeyPressEvent;
import main.commons.events.ui.TabPressEvent;
import main.logic.autocomplete.SetTrie.TrieBuilder;
import main.logic.command.DeleteCommand;
import main.logic.command.DoneCommand;
import main.logic.command.EditCommand;
import main.logic.command.FindCommand;
import main.logic.command.ListCommand;
import main.logic.parser.ReferenceList;
import main.model.Model;
import main.model.ReadOnlyTaskTracker;
import main.model.task.ReadOnlyTask;
import main.ui.UiManager;

public class AutoComplete {
        
    private static final Logger logger = LogsCenter.getLogger(AutoComplete.class);

    private SetTrie commandList;
    private SetTrie listList;
    private List<Pair<ReadOnlyTask,SetTrie>> taskList;
    private List<String> suggestions;
    private int start_index;
    private int end_index;
    private int tabCount = 0;
    EventsCenter eventsCenter;
    ReadOnlyTaskTracker tasktracker;
    
    public AutoComplete(Model model) {
        this.eventsCenter = EventsCenter.getInstance().registerHandler(this);
        this.suggestions = new ArrayList<String>();
        
        buildAllLists(model);
    }

    private void buildAllLists(Model model) {
        buildCommandList();
        buildListList();
        updateSuggestions("");
        taskList = new ArrayList<Pair<ReadOnlyTask,SetTrie>>();
        updateTaskList(model.getTaskTracker());
    }
    
    private void buildCommandList() {
        TrieBuilder build = SetTrie.builder().caseInsensitive();
        build.add(ReferenceList.commandsDictionary.keySet());
        commandList = build.build();
    }
 
    private void buildListList() {
        TrieBuilder build = SetTrie.builder().caseInsensitive();
        build.add(ReferenceList.listSet).add(ReferenceList.doneSet);
        listList = build.build();
    }
    
    /*
     * updates the taskList by iterating all tasks and storing
     * them into an array of SetTrie.
     */
    private void updateTaskList(ReadOnlyTaskTracker data) {
        tasktracker = data;

        for (ReadOnlyTask task: data.getTaskList()) {
            SetTrie trie = SetTrie.builder().caseInsensitive()
                                  .add(Arrays.stream(getTokens(task.getMessage())).collect(Collectors.toSet()))
                                  .build();
            taskList.add(Pair.of(task,trie));
        }
    }
    
    /*
     * resets the taskList using the tasktracker's data
     */
    private void resetTaskList(){
        if (tasktracker == null) return;
        updateTaskList(tasktracker);
    }

    private String[] getTokens(String input) {
        return input.trim().split(" ");
    }
    
    public void updateSuggestions(String input) {
        String[] tokens = getTokens(input);
        end_index = input.length();
        
        // is command
        if (tokens.length == 1) {
            suggestions = commandList.getSuggestions(input);
            start_index = 0;
        }
        else {
            String commandInput = tokens[0];
            
            if (ReferenceList.commandsDictionary.containsKey(commandInput)) {
                String commandWord = ReferenceList.commandsDictionary.get(commandInput);
                start_index = commandInput.length() + 1;
                
                if (isFindEditDoneDelete(commandWord) && !isToNotDisturb(tokens, commandWord)) {
                    getTaskSuggestions(tokens, commandInput);
                }
                else if(commandWord.equals(ListCommand.COMMAND_WORD)) {
                    getListSuggestions(tokens);
                }
            }
        }
        resetTaskList();
    }
    
    /*
     * returns suggestions for list parameters
     */
    private void getListSuggestions(String[] tokens) {
        suggestions = listList.getSuggestions(tokens[tokens.length-1]);
    }

    /*
     * returns suggestions for tasks
     */
    private void getTaskSuggestions(String[] tokens, String commandInput) {
        int size = updateFilteredListWithSuggestions(ArrayUtils.subarray(tokens, 1, tokens.length));
        suggestions = getStringArrayFromIndex(size);
    }

    private boolean isToNotDisturb(String[] tokens, String commandWord) {
        return !commandWord.equals(FindCommand.COMMAND_WORD) && StringUtils.isNumeric(tokens[1]);
    }

    private boolean isFindEditDoneDelete(String commandWord) {
        return commandWord.equals(EditCommand.COMMAND_WORD) || commandWord.equals(DeleteCommand.COMMAND_WORD) || commandWord.equals(DoneCommand.COMMAND_WORD) || commandWord.equals(FindCommand.COMMAND_WORD) || commandWord.equals(DoneCommand.COMMAND_WORD);
    }
    
    /*
     * updates the filtered list in real time to show matching tasks
     * 
     * @returns the size of the updated filtered list
     */
    public int updateFilteredListWithSuggestions(String[] tokens) {
        taskList = taskList.stream().filter(pair -> containPrefixInTask(pair.getValue(), tokens)).collect(Collectors.toList());
        List<ReadOnlyTask> matchedTasks = getListOfMatchedTasks();
        eventsCenter.post(new UpdateListWithSuggestionsEvent(matchedTasks));
        return matchedTasks.size();
    }
    
    private boolean containPrefixInTask(SetTrie task, String[] tokens) {

        for (String token : tokens) {
            if (task.matchPrefix(token)) {
                return true;
            }
        }
        return false;
    }
    
    private List<ReadOnlyTask> getListOfMatchedTasks() {
        List<ReadOnlyTask> matchedTasks = new ArrayList<ReadOnlyTask>();
        
        for (ReadOnlyTask task : tasktracker.getTaskList()) {
            for (Pair<ReadOnlyTask,SetTrie> pair : taskList) {
                if (task.equals(pair.getKey())){
                    matchedTasks.add(task);
                    break;
                }
            }
        }
        return matchedTasks;
    }
    
    private List<String> getStringArrayFromIndex(int size) {
        List<String> list = new ArrayList<String>();
        for (int i = 0; i < size; i++) {
            list.add(String.valueOf(i + 1));
        }
        return list;
    }
    
    /*
     * posts an autocomplete event to fill the commandBox
     */
    public void fillInSuggestions() {
        if (suggestions.size() == 0) return;
        
        String suggest = suggestions.get(tabCount % suggestions.size());

        eventsCenter.post(new AutoCompleteEvent(start_index, end_index, suggest));
        end_index = start_index + suggest.length();
        
    }
    
    /*
     * @returns suggestions
     */
    public List<String> getSuggestions() {
        return suggestions;
    }
    
    /*
     * updates suggestions when key press is detected
     */
    @Subscribe
    private void handleKeyPressEvent(KeyPressEvent event) {
        updateSuggestions(event.getInput());
        tabCount = 0;
    }
    
    /*
     * toggles the suggestions to fill in commandBox
     */
    @Subscribe
    private void handleTabPressEvent(TabPressEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        fillInSuggestions();
        tabCount++;
    }
    
    /*
     * updates taskList when tasks are changed
     */
    @Subscribe
    private void handleTaskTrackerChangedEvent(TaskTrackerChangedEvent event) {
        updateTaskList(event.data);
    }

}
```
###### /java/main/logic/LogicManager.java
``` java
package main.logic;

import main.commons.core.LogsCenter;
import main.commons.core.ComponentManager;
import main.logic.autocomplete.AutoComplete;
import main.logic.command.Command;
import main.logic.command.CommandResult;
import main.logic.parser.MainParser;
import main.model.Model;
import main.model.task.ReadOnlyTask;
import main.storage.Storage;

import java.util.logging.Logger;

import javafx.collections.ObservableList;

/**
 * The main LogicManager of the app.
 */
public class LogicManager extends ComponentManager implements Logic {
    private final Logger logger = LogsCenter.getLogger(LogicManager.class);

    private final Model model;
    private final MainParser parser;
    private final AutoComplete autoComplete;
    private final Storage storage;

    public LogicManager(Model model, Storage storage) {
        this.model = model;
        this.parser = new MainParser();
        this.autoComplete = new AutoComplete(model);
        this.storage = storage;
    }

```
###### /java/main/logic/LogicManager.java
``` java
    @Override
    public ObservableList<ReadOnlyTask> getFilteredTaskList() {
        return model.getFilteredTaskList();
    }
    
    @Override
    public int getNumToday(){
        return model.getNumToday();
    }
    
    @Override
    public int getNumTmr(){
        return model.getNumTmr();
    }
    
    @Override
    public int getNumEvent(){
        return model.getNumEvent();
    }
    
    @Override
    public int getNumDeadline(){
        return model.getNumDeadline();
    }
    
    @Override
    public int getNumFloating(){
        return model.getNumFloating();
    }
    
    @Override
    public int getTotalNum(){
        return model.getTotalNum();
    }
}
```
###### /java/main/model/Model.java
``` java
    /** Returns the filtered task list as an {@code UnmodifiableObservableList<ReadOnlyTask>} */
    UnmodifiableObservableList<ReadOnlyTask> getFilteredTaskList();

    /** Updates the filter of the filtered task list to show all pending tasks */
    void updateFilteredListToShowAllPending();

    /** Updates the filter of the filtered task list to show all completed tasks */    
    void updateFilteredListToShowAllDone();
    
    /** Returns the number of tasks today **/
    int getNumToday();

    /** Returns the number of tasks tomorrow **/
    int getNumTmr();
    
    /** Returns the total number of events in the list **/
    int getNumEvent();

    /** Returns the total number of tasks with deadline in the list **/
    int getNumDeadline();
    
    /** Returns the total number of floating tasks in the list **/
    int getNumFloating();

    /** Returns the total number of tasks in the list **/
    int getTotalNum();

    /** Updates the FilteredList based on criterias given **/
    void updateFilteredTaskList(Triple<PriorityType, Date, TaskType> params, boolean isDone);

    /** Sorts the list based on criterias given **/
    void sortBy(SortCriteria criteria);

    /** THe default sorting done at the start **/
    void sortDefault();



	




    
}
```
###### /java/main/model/ModelManager.java
``` java
// adapted from addressbook level 4
package main.model;

import main.commons.core.ComponentManager;
import main.commons.core.EventsCenter;
import main.commons.core.LogsCenter;
import main.commons.core.UnmodifiableObservableList;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.LinkedList;
import java.util.List;
import java.util.Stack;
//import java.util.function.Predicate;
import java.util.logging.Logger;
//import java.util.LinkedList;

import org.apache.commons.lang3.tuple.Triple;

import com.google.common.collect.Lists;
import com.google.common.eventbus.Subscribe;

import javafx.collections.ObservableList;
import javafx.collections.transformation.FilteredList;
import javafx.collections.transformation.SortedList;
import main.commons.events.model.ChangeSortFilterEvent;
import main.commons.events.model.TaskTrackerChangedEvent;
import main.commons.events.model.UpdateListWithSuggestionsEvent;
import main.commons.util.DateUtil;

import main.logic.command.UndoCommand;
import main.model.ModelManager.Qualifier;

import main.model.TaskTracker;
import main.model.filter.SortCriteria;
import main.model.filter.SortFilter;
import main.model.task.PriorityType;
import main.model.task.ReadOnlyTask;
import main.model.task.Task;
import main.model.task.TaskType;
import main.model.task.UniqueTaskList.DuplicateTaskException;
import main.model.task.UniqueTaskList.TaskNotFoundException;

public class ModelManager extends ComponentManager implements Model {
    private static final Logger logger = LogsCenter.getLogger(ModelManager.class);
    EventsCenter eventsCenter;
    
    public static Stack<UndoHistory> undoStack;
    public static Stack<UndoHistory> redoStack;
    
    TaskTracker taskTracker;
    UserPrefs userPref;
    private final FilteredList<Task> filteredTasks;
    private final SortedList<Task> sortedTasks;
    Expression baseExpression;
    
    public ModelManager(TaskTracker taskTracker, UserPrefs userPref) {
        super();
        assert taskTracker != null;
        assert userPref != null;

        logger.fine("Initializing with task tracker: " + taskTracker + " and user prefs " + userPref);
        eventsCenter = EventsCenter.getInstance();
        eventsCenter.registerHandler(this);
        
        this.taskTracker = new TaskTracker(taskTracker);
        this.userPref = userPref;
        filteredTasks = new FilteredList<>(this.taskTracker.getTasks());
        sortedTasks = new SortedList<>(this.filteredTasks);
        sortDefault();
        
        undoStack = new Stack<UndoHistory>();
        redoStack = new Stack<UndoHistory>();
    }
    
    public ModelManager() {
        this(new TaskTracker(), new UserPrefs());
    }

    @Override
    public void resetData(ReadOnlyTaskTracker newData) {
        if(newData.getTaskList().size()==0){
            List<ReadOnlyTask> prevTasks = taskTracker.getTaskList();
            addToUndo(UndoCommand.CLR, prevTasks.toArray(new Task [prevTasks.size()]));
        }
        taskTracker.resetData(newData);
        indicateTaskTrackerChanged();
    }
    
    public void setTasks(List<Task> tasks) {
        this.taskTracker.getUniqueTaskList().getInternalList().setAll(tasks);
}

    @Override
    public ReadOnlyTaskTracker getTaskTracker() {
        return taskTracker;
    }

    @Override
    public synchronized void deleteTask(int index) throws TaskNotFoundException {
        ReadOnlyTask target = getTaskfromIndex(index);
        taskTracker.removeTask(target);
        indicateTaskTrackerChanged();
        addToUndo(UndoCommand.DEL, (Task)target);
    }
    
    @Override
    public synchronized void doneTask(int index) throws TaskNotFoundException {
        ReadOnlyTask target = getTaskfromIndex(index);
        taskTracker.doneTask(target);
        indicateTaskTrackerChanged();
        addToUndo(UndoCommand.DONE,(Task)target);
    }
    
    @Override
    public synchronized void editTask(int index, Task newtask) throws TaskNotFoundException, DuplicateTaskException {
        addToUndo(UndoCommand.EDIT, getTaskfromIndex(index), newtask);  //NEED TO CHECK ORDER
        taskTracker.editTask(index, newtask);
        updateFilteredListToShowAllPending();
        indicateTaskTrackerChanged();
        
    }
    
    
    
    /** Raises an event to indicate the model has changed */
    private void indicateTaskTrackerChanged() {
        raise(new TaskTrackerChangedEvent(taskTracker));
}

    @Override
    public synchronized void addTask(Task task) throws DuplicateTaskException {
        taskTracker.addTask(task);
        updateFilteredListToShowAllPending();
        indicateTaskTrackerChanged();
        addToUndo(UndoCommand.ADD, task);
    }
    
  //  @Override
  //  public synchronized void overdueTask(int index) throws TaskNotFoundException, DuplicateTaskException {
  // 	ReadOnlyTask target = getTaskfromIndex(index);
  //      taskTracker.overdueTask(target);
  //      indicateTaskTrackerChanged();
  //  }
    
    //=========== Sorting ===================================================================
    @Override
    public void sortBy(SortCriteria criteria) {
        sortedTasks.setComparator(new SortFilter(criteria).getComparator());
    }
    
    @Override
    public void sortDefault() {
        sortBy(SortCriteria.TIME);
    }
    
    @Subscribe
    public void handleChangeSortFilterEvent(ChangeSortFilterEvent event) {
        sortBy(event.getSortCriteria());
    }
    
    //=========== User Friendly Accessors ===================================================================
    @Override
    public int getNumToday() {
        Expression original = baseExpression;
        updateFilteredTaskList(Triple.of(null, DateUtil.getToday(), null), false);
        return getSizeAndReset(original);
    }
    
    @Override
    public int getNumTmr() {
        Expression original = baseExpression;
        updateFilteredTaskList(Triple.of(null, DateUtil.getTmr(), null), false);
        return getSizeAndReset(original);
    }
    
    @Override
    public int getNumEvent() {
        Expression original = baseExpression;
        updateFilteredTaskList(Triple.of(null, null, TaskType.EVENT), false);
        return getSizeAndReset(original);  
    }
    
    @Override
    public int getNumDeadline() {
        Expression original = baseExpression;
        updateFilteredTaskList(Triple.of(null, null, TaskType.DEADLINE), false);
        return getSizeAndReset(original);         
    }
    
    @Override
    public int getNumFloating() {
        Expression original = baseExpression;
        updateFilteredTaskList(Triple.of(null, null, TaskType.FLOATING), false);
        return getSizeAndReset(original); 
    }
    
    @Override 
    public int getTotalNum() {
        Expression original = baseExpression;
        updateFilteredListToShowAllPending();
        return getSizeAndReset(original);
    }

    private int getSizeAndReset(Expression original) {
        int num = filteredTasks.size();
        if (original == null) updateFilteredListToShowAllPending();
        else updateFilteredTaskList(original);
        return num;
    }
    

    //=========== Filtered Task List Accessors ===============================================================

    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getFilteredTaskList() {
        return new UnmodifiableObservableList<>(sortedTasks);        
    }

    @Override
    public void updateFilteredListToShowAllPending() {
        Expression filter = new PredicateExpression();
        filter.and(new DoneQualifier(false));
        
        updateFilteredTaskList(filter);
        baseExpression = filter;
    }
    
    @Override
    public void updateFilteredListToShowAllDone() {
        Expression filter = new PredicateExpression();
        filter.and(new DoneQualifier(true));
        
        updateFilteredTaskList(filter);
        baseExpression = filter;
    }
    
    
    @Override
    public void updateFilteredTaskList(Triple<PriorityType, Date, TaskType> params, boolean isDone) {
        Expression filter = new PredicateExpression();
        
        filter.and(new DoneQualifier(isDone));
        
        if (params.getLeft() != null) filter.and(new PriorityQualifier(params.getLeft()));
        if (params.getMiddle() != null) filter.and(new DateQualifier(params.getMiddle()));        
        if (params.getRight() != null) filter.and(new TypeQualifier(params.getRight()));
        
        updateFilteredTaskList(filter);
        baseExpression = filter;
    }
    
    public void updateFilteredTaskList(Expression expression) {
        baseExpression = expression;
        filteredTasks.setPredicate(expression::satisfies);
    }
    
    //============= AutoComplete Suggestions ========================================
    
    @Subscribe
    public void handleUpdateSuggestionsEvent(UpdateListWithSuggestionsEvent event) {
        List<ReadOnlyTask> suggestions = event.getSuggestions();

        Expression filter = new PredicateExpression();
        filter.and(new MatchQualifier(suggestions));
        filter.and(new DoneQualifier(false));
        updateFilteredTaskList(filter);
    }
    
    //========== Inner classes/interfaces used for filtering =================================================
    
    interface Expression {
        boolean satisfies(ReadOnlyTask task);
        void and(Qualifier qualifier);
        String toString();
    }

    private class PredicateExpression implements Expression {

        private List<Qualifier> qualifier = Lists.newArrayList();
        
        public PredicateExpression() {}
        
        @Override
        public void and(Qualifier qualifier) {
            this.qualifier.add(qualifier);
        }

        @Override
        public boolean satisfies(ReadOnlyTask task) {
            boolean qualify = true;
            
            for (Qualifier q : qualifier) {
                qualify = qualify && q.run(task); 
            }
            
            return qualify;
        }

        @Override
        public String toString() {
            return qualifier.toString();
        }
    }       

    interface Qualifier {
        boolean run(ReadOnlyTask task);
        String toString();
    }

    private class DateQualifier implements Qualifier {
        private Date date;

        DateQualifier(Date date) {
            this.date = date;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
//            return date.stream()
//                    .filter(keyword -> StringUtil.containsWordIgnoreCase(person.getName().fullName, keyword))
//                    .findAny()
//                    .isPresent();
//            return ((compareDate(date, task.getDeadline())) || (compareDate(date, task.getEndTime())) || (compareDate(date, task.getStartTime())));
            if (task.getIsEvent()) return DateUtil.dateWithin(task.getStartTime(), task.getEndTime(), date);
            else if (!task.getIsFloating() && !task.getIsEvent()) return DateUtil.areSameDay(date, task.getDeadline()); 
            else return false;
        }


        @Override
        public String toString() {
            return ((new SimpleDateFormat("dd MMM")).format(this.date));
        }
    }
    
    private class TypeQualifier implements Qualifier {
        private TaskType type;

        TypeQualifier(TaskType type) {
            this.type = type;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            return task.getType() == type;
        }

        @Override
        public String toString() {
            return type.name();
        }
    }
    
    private class PriorityQualifier implements Qualifier {
        private PriorityType priority;

        PriorityQualifier(PriorityType priority) {
            this.priority = priority;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            return priority == task.getPriority();
        }

        @Override
        public String toString() {
            return priority.toString();
        }
    }
    
    private class DoneQualifier implements Qualifier {
        private boolean isDone;

        DoneQualifier(boolean isDone) {
            this.isDone = isDone;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            return isDone == task.getIsDone();
        }

        @Override
        public String toString() {
            return String.valueOf(isDone);
        }        
        
    }

    private class MatchQualifier implements Qualifier {
        private List<ReadOnlyTask> matches;

        MatchQualifier(List<ReadOnlyTask> matches) {
            this.matches = matches;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            return matches.stream().filter(t -> t.equals(task)).findFirst().isPresent();
        }

        @Override
        public String toString() {
            return String.valueOf(matches);
        }        
        
    }
    
    //================= Functions for undo and redo ==================================
```
###### /java/main/model/filter/SortFilter.java
``` java
package main.model.filter;

import java.util.Comparator;
import main.model.task.Task;

public class SortFilter {
    

    //Sort by comparing deadlines and end date of events
    Comparator<Task> byTime = (t1, t2) -> t1.compareTime(t2);

    //Sort lexicographically, case insensitive
    Comparator<Task> byName = (t1, t2) -> t1.getMessage().toLowerCase().compareTo(t2.getMessage().toLowerCase());

    
    private Comparator<Task> sortCriteria;
    private boolean isReversed = false;
    
    public SortFilter(SortCriteria criteria) {
        switch (criteria) {
            case TIME:
                sortCriteria = byTime.thenComparing(byName);
//                isReversed = false;
                break;
            case NAME:
                sortCriteria = byName.thenComparing(byTime); 
//                isReversed = true; // so appears in the order a-z
                break;
            default:
                sortCriteria = byTime.thenComparing(byName);
//                isReversed = false;
                break;
        }
    }
    
    public Comparator<Task> getComparator() {
        if (isReversed) return sortCriteria.reversed();
        else return sortCriteria;
    }
    
    public void setReverse(boolean reverse) {
        isReversed = reverse;
    }
}
```
###### /java/main/model/filter/SortCriteria.java
``` java
package main.model.filter;

public enum SortCriteria {
    TIME, NAME
}
```
###### /java/main/commons/events/ui/TabPressEvent.java
``` java
package main.commons.events.ui;

import javafx.scene.input.KeyCode;
import main.commons.events.BaseEvent;

public class TabPressEvent extends BaseEvent{
    
    private KeyCode button;
    
    public TabPressEvent(KeyCode button) {
        this.button = button;
    }

    public KeyCode getKey() {
        return button;
    }
    
    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### /java/main/commons/events/ui/AutoCompleteEvent.java
``` java
package main.commons.events.ui;

import main.commons.events.BaseEvent;

public class AutoCompleteEvent extends BaseEvent{
    
    // the start and end index of the input to be replaced
    int start;
    int end;
    
    String suggestion;
    
    public AutoCompleteEvent(int start, int end, String suggestion) {
        this.suggestion = suggestion;
        this.start = start;
        this.end = end;
    }
    
    public String getSuggestion() {
        return suggestion;
    }
    
    public int getStart() {
        return start;
    }
    
    public int getEnd() {
        return end;
    }
    
    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### /java/main/commons/events/ui/KeyPressEvent.java
``` java
package main.commons.events.ui;

import javafx.scene.input.KeyCode;
import main.commons.events.BaseEvent;

public class KeyPressEvent extends BaseEvent{
    private String input;
    private KeyCode button;

    public KeyPressEvent(KeyCode button, String input) {
        this.button = button;
        this.input = input;
    }
    
    public KeyCode getKey() {
        return button;
    }
    
    public String getInput() {
        return input;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }
    

}
```
###### /java/main/commons/events/model/UpdateListWithSuggestionsEvent.java
``` java
package main.commons.events.model;

import java.util.List;

import main.commons.events.BaseEvent;
import main.model.task.ReadOnlyTask;

public class UpdateListWithSuggestionsEvent extends BaseEvent {
    private List<ReadOnlyTask> suggestions;
    
    public UpdateListWithSuggestionsEvent(List<ReadOnlyTask> suggestions) {
        this.suggestions = suggestions;
    }
    
    public List<ReadOnlyTask> getSuggestions() {
        return suggestions;
    }

    @Override
    public String toString() {
        return "" + suggestions.size() + " matching tasks found";
    }

}
```
###### /java/main/commons/events/model/ChangeSortFilterEvent.java
``` java
package main.commons.events.model;

import main.commons.events.BaseEvent;
import main.model.filter.SortCriteria;

public class ChangeSortFilterEvent extends BaseEvent {

    SortCriteria filter;
    
    public ChangeSortFilterEvent(String param) {
        assert param.equals("date") || param.equals("name");
        matchToFilter(param);
    }

    private void matchToFilter(String param) {
        if (param.equals("date")) {
            filter = SortCriteria.TIME;
        }
        else {
            filter = SortCriteria.NAME;
        }
    }
    
    public SortCriteria getSortCriteria() {
        return filter;
    }

    @Override
    public String toString() {
        return filter.name();
    }

}
```
###### /java/main/commons/exceptions/MultiplePriorityException.java
``` java
package main.commons.exceptions;

public class MultiplePriorityException extends IllegalArgumentException {
    public MultiplePriorityException() {
        super();
    }
}
```
###### /java/main/commons/core/Messages.java
``` java
    public static final String MESSAGE_EMPTY_DESCRIPTION = "Task description must be provided";
    public static final String MESSAGE_MULTIPLE_PRIORITY = "Task can only have 1 priority level";
    public static final String MESSAGE_INVALID_PARAMETERS = "Invalid %1$s parameters! \n %2$s";
    
}
```
###### /java/main/commons/util/DateUtil.java
``` java
package main.commons.util;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;

public class DateUtil {
    
    /*
     * convenient constructor for Date, with time
     * 
     * @returns a Date object
     */
    public static Date getDate(int year, int month, int day, int hour, int min){
        Calendar cal = Calendar.getInstance();
        cal.set(year, month, day, hour, min);
        return cal.getTime();
    }

    /*
     * convenient constructor for Date, without time
     * 
     * @returns a Date object
     */
    public static Date getDate(int year, int month, int day){
        Calendar cal = Calendar.getInstance();
        cal.set(year, month, day);
        return cal.getTime();
    }
    
    /*
     * @returns today's date
     */
    public static Date getToday(){
        Calendar cal = Calendar.getInstance();
        return setTime(cal.getTime(), 8, true);
    }
    
    public static Date getTmr() {
        Calendar cal = Calendar.getInstance();
        cal.setTime(getToday());
        cal.add(Calendar.DATE, 1);
        return cal.getTime();
    }
     
    /*
     * checks if the date is within start and end
     * 
     * @returns true if the given date is within the start and end date
     */
    public static boolean dateWithin(Date start, Date end, Date date) {
        if (start == null || end == null || date == null) return false;
        if (start.before(date) && end.after(date)) return true;
        else return false;
    }
    
    /*
     * compares the 2 dates, not including the time
     * 
     * @returns true if both dates are on the same day
     */
    public static boolean areSameDay(Date date1, Date date2) {
        if (date1 == null | date2 == null) return false;
        Calendar cal1 = Calendar.getInstance();
        cal1.setTime(date1);
        
        Calendar cal2 = Calendar.getInstance();
        cal2.setTime(date2);
        
        if ((cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR)) 
            && (cal1.get(Calendar.MONTH) == cal2.get(Calendar.MONTH)) 
            && (cal1.get(Calendar.DATE) == cal2.get(Calendar.DATE))) {
            return true;
        }
        else return false;
    }
    
    
    /*
     * @returns a date with a nice readable format
     */
    public static String readableDate(Date date, boolean isInferred) {
        DateFormat df;
        if (isInferred) {
            df = new SimpleDateFormat("dd MMM");
        }
        else {
            df = new SimpleDateFormat("dd MMM h:mm a");            
        }
        return df.format(date);
    }
    
    /*
     * takes isInferred as true by default
     * 
     * @returns a a date with a nice readable format, without time
     */
    public static String readableDate(Date date) {
        return readableDate(date, true);
    }
    
    /*
     * changes the time to the hour given (in 24 hours format) and
     * resets minutes, depending on the boolean input
     *       
     * @returns the original date with given time
     */
    public static Date setTime(Date date, int hour, boolean resetMinutes) {
        Calendar cal = Calendar.getInstance();
        cal.setTime(date);
        cal.set(Calendar.HOUR_OF_DAY, hour);
        if (resetMinutes) {
            cal.clear(Calendar.MINUTE);
            cal.clear(Calendar.SECOND);
            cal.clear(Calendar.MILLISECOND);
        }
        return cal.getTime();
    }
```
###### /java/main/commons/util/DateUtil.java
``` java
    public static Date defaultTime(Date date) {
        return setTime(date, 8, true);
    }
}

```
