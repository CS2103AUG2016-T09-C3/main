# A0142686X
###### \java\main\logic\command\RedoCommand.java
``` java
package main.logic.command;

import main.model.ModelManager;
import main.model.ReadOnlyTaskTracker;
import main.model.TaskTracker;
import main.model.UndoHistory;
import main.model.task.Task;
import main.model.task.UniqueTaskList;
import main.model.task.UniqueTaskList.DuplicateTaskException;
import main.model.task.UniqueTaskList.TaskNotFoundException;
/**
     * Redoes the previous undo'd command. 
     * Pops from redo stack and executes appropriate add/del/edit/clr commands
     * 
 */

public class RedoCommand extends Command {

    public static final String COMMAND_WORD = "redo";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Reverts the last known command undo.\n" + "eg. "
            + COMMAND_WORD;

    public static final String MESSAGE_SUCCESS = "Reverted last undo. ";
    public static final String MESSAGE_EMPTY_HISTORY = "There are no more undos before this.";

    public static final int ADD = 1;
    public static final int DEL = 2;
    public static final int EDIT = 3;
    public static final int DONE = 4;
    public static final int CLR = 5;
    
    private UndoHistory redoHistory;
    
    @Override
    public CommandResult execute() {
        if(ModelManager.redoStack.size()==0) {
            return new CommandResult(MESSAGE_EMPTY_HISTORY);
        }
        redoHistory=ModelManager.redoStack.pop();
        int ID=redoHistory.getID();
        
        if(ID==ADD) {
           redoAdd(redoHistory.getTasks().get(0));
           return new CommandResult(MESSAGE_SUCCESS);
        }
        if(ID==DEL) {
            redoDelete(redoHistory.getTasks().get(0));
            return new CommandResult(MESSAGE_SUCCESS);
        }
        if(ID==EDIT) {
            try {
                try {
                    redoEdit(redoHistory.getTasks().get(0), redoHistory.getTasks().get(1));
                } catch (DuplicateTaskException | TaskNotFoundException e) {
                    e.printStackTrace();
                }
            } catch (IndexOutOfBoundsException e) {
                e.printStackTrace();
            }
            return new CommandResult(MESSAGE_SUCCESS);
        }
        if(ID==CLR) {
            redoClear();
            return new CommandResult(MESSAGE_SUCCESS);
        }
        if(ID==DONE) {
            try {
                redoDone(redoHistory.getTasks().get(0));
            } catch (IndexOutOfBoundsException | TaskNotFoundException e) {
                e.printStackTrace();
            }
            return new CommandResult(MESSAGE_SUCCESS);
        }
        return new CommandResult(MESSAGE_EMPTY_HISTORY);
    }
    
    private void redoAdd(Task task) {
        try {
            model.addTask(task);
        } catch (DuplicateTaskException e) {
            e.printStackTrace();
        }
    }
    private void redoDelete(Task task) {
        try {
            model.deleteTask(model.getIndexFromTask(task));
        } catch (TaskNotFoundException e) {
            e.printStackTrace();
        }
    }
    private void redoEdit(Task newTask, Task originalTask) throws DuplicateTaskException, IndexOutOfBoundsException, TaskNotFoundException {
        model.editTask(model.getIndexFromTask(originalTask), newTask);
    }
    
    private void redoClear() {
        model.resetData((ReadOnlyTaskTracker) new TaskTracker(new UniqueTaskList()));
    }
    
    private void redoDone(Task task) throws IndexOutOfBoundsException, TaskNotFoundException {
        model.doneTask(model.getIndexFromTask(task));
    }
        
}
```
###### \java\main\logic\command\UndoCommand.java
``` java
package main.logic.command;

import java.util.ArrayList;
import java.util.IllegalFormatCodePointException;

import main.model.ModelManager;
import main.model.UndoHistory;
import main.model.task.Task;
import main.model.task.UniqueTaskList.DuplicateTaskException;
import main.model.task.UniqueTaskList.TaskNotFoundException;
    
/**
     *Undoes the previous command. 
     *Maintains a stack of changes made by last entered command
     *Pushes the undo'd command to redo stack
     *
 */ 
public class UndoCommand extends Command {

    public static final String COMMAND_WORD = "undo";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Reverts the last known command input.\n" + "eg. "
            + COMMAND_WORD;

    public static final String MESSAGE_SUCCESS = "Reverted last command. ";
    public static final String MESSAGE_EMPTY_HISTORY = "There are no more inputs before this.";

    public static final int ADD = 1;
    public static final int DEL = 2;
    public static final int EDIT = 3;
    public static final int DONE = 4;
    public static final int CLR = 5;
    
    private UndoHistory undoHistory;

    @Override
    public CommandResult execute() {
        if(ModelManager.undoStack.size()==0) {
            return new CommandResult(MESSAGE_EMPTY_HISTORY);
        }
        undoHistory=ModelManager.undoStack.pop();
        ModelManager.redoStack.push(undoHistory);
        int ID=undoHistory.getID();
        
        if(ID==ADD) {
           undoAdd(undoHistory.getTasks().get(0));
           return new CommandResult(MESSAGE_SUCCESS);
        }
        if(ID==DEL) {
            undoDelete(undoHistory.getTasks().get(0));
            return new CommandResult(MESSAGE_SUCCESS);
        }
        if(ID==CLR) {
            undoClear(undoHistory.getTasks());
            return new CommandResult(MESSAGE_SUCCESS);
        }
        if(ID==EDIT) {
            try {
                undoEdit(undoHistory.getTasks().get(0), undoHistory.getTasks().get(1));
            } catch (DuplicateTaskException e) {
                e.printStackTrace();
            } catch (IndexOutOfBoundsException e) {
                e.printStackTrace();
            } catch (TaskNotFoundException e) {
                e.printStackTrace();
            }
            return new CommandResult(MESSAGE_SUCCESS);
        }
        if(ID==DONE) {
            try {
                undoDone(undoHistory.getTasks().get(0));
            } catch (DuplicateTaskException | TaskNotFoundException e) {
                e.printStackTrace();
            }
            return new CommandResult(MESSAGE_SUCCESS);
        }
        return new CommandResult(MESSAGE_EMPTY_HISTORY);
    }
    
    private void undoAdd(Task task) {
        try {
            model.deleteTaskUndoRedo(task);
        } catch (TaskNotFoundException e) {
            e.printStackTrace();
        }
    }
    private void undoDelete(Task task) {
        try {
            model.addTaskUndoRedo(task);
        } catch (DuplicateTaskException e) {
            e.printStackTrace();
        }
    }
    private void undoEdit(Task newTask, Task originalTask) throws DuplicateTaskException, IndexOutOfBoundsException, TaskNotFoundException{
        model.editTaskUndoRedo(model.getIndexFromTask(originalTask), newTask);
    }
    
    private void undoClear(ArrayList<Task> tasks) {
        model.clearTaskUndoRedo(tasks);
    }
    
    private void undoDone(Task task) throws DuplicateTaskException, TaskNotFoundException {
        model.doneTaskUndoRedo(task);
    }
}
```
###### \java\main\logic\parser\MainParser.java
``` java
    public Command prepareUndo() {
        return new UndoCommand();
    }
    
    public Command prepareRedo() {
        return new RedoCommand();
    }
    
```
###### \java\main\model\Model.java
``` java
    /** Returns the Task at a specific index number inside TaskTracker **/
    Task getTaskfromIndex(int index) throws  UniqueTaskList.TaskNotFoundException, IndexOutOfBoundsException;
    
    /** Returns index number of specific task inside TaskTracker **/
    int getIndexFromTask(ReadOnlyTask task) throws UniqueTaskList.TaskNotFoundException, IndexOutOfBoundsException;
    
    /** Adds task upon undo **/
    void addTaskUndoRedo(Task task) throws DuplicateTaskException;
    
    /** Deletes task upon undo **/
    void deleteTaskUndoRedo(ReadOnlyTask target) throws TaskNotFoundException;
    
    /** Edits task upon undo **/
    void editTaskUndoRedo(int index, Task newTask) throws DuplicateTaskException;
    
    /** Clears Tasks upon undo **/
    void clearTaskUndoRedo(ArrayList<Task> tasks);
    
    /** re-adds a done task upon undo 
     * @throws DuplicateTaskException 
     * @throws TaskNotFoundException **/
    void doneTaskUndoRedo(Task Task) throws DuplicateTaskException, TaskNotFoundException;
    
```
###### \java\main\model\ModelManager.java
``` java
    
    /**
     * Adds task or multiple tasks to the undo stack
     * 
     */
    private void addToUndo(int ID, Task... tasks) {
        UndoHistory undoHistory = new UndoHistory(ID, tasks);
        undoStack.push(undoHistory);
    }
    
    /**
     * Method used by undo and redo to add tasks into tasktracker
     */
    @Override
    public void addTaskUndoRedo(Task task) throws DuplicateTaskException {
        taskTracker.addTask(task);
        updateFilteredListToShowAllPending();
        indicateTaskTrackerChanged();
        
    }
    
    /**
     * Method used by undo and redo to delete tasks from tasktracker
     */
    @Override
    public void deleteTaskUndoRedo(ReadOnlyTask target) throws TaskNotFoundException {
        taskTracker.removeTask(target);
        indicateTaskTrackerChanged();
        
    }

    /**
     * Method used by undo and redo to edit tasks in tasktracker
     */
    @Override
    public void editTaskUndoRedo(int index, Task newTask) throws DuplicateTaskException {
        taskTracker.editTask(index, newTask);
        updateFilteredListToShowAllPending();
        indicateTaskTrackerChanged();
        
    }
    
    /**
     * Method used by undo and redo to clear tasktracker
     */
    @Override
    public void clearTaskUndoRedo(ArrayList<Task> tasks) {
        TaskTracker prevTaskTracker = new TaskTracker();
        prevTaskTracker.setTasks(tasks);
        taskTracker.resetData(prevTaskTracker);
    }
    
    @Override
    public void doneTaskUndoRedo(Task task) throws DuplicateTaskException, TaskNotFoundException {
        taskTracker.incompleteTask(task);
        updateFilteredListToShowAllPending();
        indicateTaskTrackerChanged();
    }
    
    /**
     * Method to get task from tasktracker at a given index
     */
    @Override 
    public Task getTaskfromIndex(int index) throws TaskNotFoundException {
        Task task;
        
        try {
            task = sortedTasks.get(index);
        } catch (IndexOutOfBoundsException e) {
            throw new TaskNotFoundException();
        }
        
        return task;
    }
    
    /**
     * Method to get index of a given task in tasktracker 
     */
    @Override
    public int getIndexFromTask(ReadOnlyTask task) throws TaskNotFoundException {
        int index;
        List<ReadOnlyTask> temp = new LinkedList<ReadOnlyTask>();
        temp=taskTracker.getTaskList();
        index=temp.lastIndexOf(task);
        return index;
    }
}

```
###### \java\main\model\task\UniqueTaskList.java
``` java
    /**
     * method to mark a task not-done in tasktracker
     * @throws TaskNotFoundException 
     */
    public boolean incomplete(ReadOnlyTask toIncomplete) throws TaskNotFoundException {
        assert toIncomplete != null;
        if (!internalList.contains(toIncomplete)) {
            throw new TaskNotFoundException();
        }
        Task taskFoundAndCompleted = internalList.get(internalList.indexOf(toIncomplete));
        return taskFoundAndCompleted.setIsUnDone();
    }
```
###### \java\main\model\UndoHistory.java
``` java
package main.model;

import java.util.ArrayList;
import java.util.Collection;

import edu.emory.mathcs.backport.java.util.Arrays;
import main.model.task.Task;

public class UndoHistory {
    /**
     * Maintains an ArrayList of tasks changed in Tasktracker at every command.
     * 
     */
    
    private int ID;
    private ArrayList<Task> tasks;
    
    public UndoHistory(int ID, Task... tasks) {
        this.ID = ID;
        Collection<Task> collection = Arrays.asList(tasks);
        this.tasks = new ArrayList<Task>(collection);       
    }
    
    
    public int getID() {
        return ID;
    }
    
    public ArrayList<Task> getTasks() {
        return tasks;
    }
    
}
```
###### \java\main\storage\JsonUserPrefsStorage.java
``` java
package main.storage;

import main.commons.exceptions.DataConversionException;
import main.commons.util.FileUtil;
import main.model.UserPrefs;

import java.io.File;
import java.io.IOException;
import main.commons.core.LogsCenter;
import java.util.Optional;
import java.util.logging.Logger;

/**
 * A class to access UserPrefs stored in the hard disk as a json file
 */
public class JsonUserPrefsStorage implements UserPrefsStorage{

    private static final Logger logger = LogsCenter.getLogger(JsonUserPrefsStorage.class);

    private String filePath;

    public JsonUserPrefsStorage(String filePath){
        this.filePath = filePath;
    }

    @Override
    public Optional<UserPrefs> readUserPrefs() throws DataConversionException, IOException {
        return readUserPrefs(filePath);
    }

    @Override
    public void saveUserPrefs(UserPrefs userPrefs) throws IOException {
        saveUserPrefs(userPrefs, filePath);
    }

    /**
     * Similar to {@link #readUserPrefs()}
     * @param prefsFilePath location of the data. Cannot be null.
     * @throws DataConversionException if the file format is not as expected.
     */
    public Optional<UserPrefs> readUserPrefs(String prefsFilePath) throws DataConversionException {
        assert prefsFilePath != null;

        File prefsFile = new File(prefsFilePath);

        if (!prefsFile.exists()) {
            logger.info("Prefs file "  + prefsFile + " not found");
            return Optional.empty();
        }

        UserPrefs prefs;

        try {
            prefs = FileUtil.deserializeObjectFromJsonFile(prefsFile, UserPrefs.class);
        } catch (IOException e) {
            logger.warning("Error reading from prefs file " + prefsFile + ": " + e);
            throw new DataConversionException(e);
        }

        return Optional.of(prefs);
    }

    /**
     * Similar to {@link #saveUserPrefs(UserPrefs)}
     * @param prefsFilePath location of the data. Cannot be null.
     */
    public void saveUserPrefs(UserPrefs userPrefs, String prefsFilePath) throws IOException {
        assert userPrefs != null;
        assert prefsFilePath != null;

        FileUtil.serializeObjectToJsonFile(new File(prefsFilePath), userPrefs);
    }
}
```
###### \java\main\storage\Storage.java
``` java
package main.storage;

import main.commons.events.model.TaskTrackerChangedEvent;
import main.commons.events.storage.DataSavingExceptionEvent;
import main.commons.exceptions.DataConversionException;
import main.model.ReadOnlyTaskTracker;
import main.model.UserPrefs;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.Optional;

/**
 * API of the Storage component
 */
public interface Storage extends TaskTrackerStorage, UserPrefsStorage {

    @Override
    Optional<UserPrefs> readUserPrefs() throws DataConversionException, IOException;

    @Override
    void saveUserPrefs(UserPrefs userPrefs) throws IOException;

    @Override
    String getTaskTrackerFilePath();

    @Override
    Optional<ReadOnlyTaskTracker> readTaskTracker() throws DataConversionException, IOException;

    @Override
    void saveTaskTracker(ReadOnlyTaskTracker taskTracker) throws IOException;

    /**
     * Saves the current version of the TaskTracker to the hard disk.
     *   Creates the data file if it is missing.
     * Raises {@link DataSavingExceptionEvent} if there was an error during saving.
     */
    void handleTaskTrackerChangedEvent(TaskTrackerChangedEvent abce);
}
```
###### \java\main\storage\StorageManager.java
``` java
package main.storage;

import com.google.common.eventbus.Subscribe;
import main.commons.core.ComponentManager;
import main.commons.core.LogsCenter;
import main.commons.events.model.TaskTrackerChangedEvent;
import main.commons.events.storage.DataSavingExceptionEvent;
import main.commons.exceptions.DataConversionException;
import main.model.ReadOnlyTaskTracker;
import main.model.UserPrefs;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.Optional;
import java.util.logging.Logger;

/**
 * Manages storage of TaskTracker data in local storage.
 */
public class StorageManager extends ComponentManager implements Storage {

    private static final Logger logger = LogsCenter.getLogger(StorageManager.class);
    private TaskTrackerStorage taskTrackerStorage;
    private UserPrefsStorage userPrefsStorage;


    public StorageManager(TaskTrackerStorage taskTrackerStorage, UserPrefsStorage userPrefsStorage) {
        super();
        this.taskTrackerStorage = taskTrackerStorage;
        this.userPrefsStorage = userPrefsStorage;
    }

    public StorageManager(String taskTrackerFilePath, String userPrefsFilePath) {
        this(new XmlTaskTrackerStorage(taskTrackerFilePath), new JsonUserPrefsStorage(userPrefsFilePath));
    }

    // ================ UserPrefs methods ==============================

    @Override
    public Optional<UserPrefs> readUserPrefs() throws DataConversionException, IOException {
        return userPrefsStorage.readUserPrefs();
    }

    @Override
    public void saveUserPrefs(UserPrefs userPrefs) throws IOException {
        userPrefsStorage.saveUserPrefs(userPrefs);
    }


    // ================ TaskTracker methods ==============================

    @Override
    public String getTaskTrackerFilePath() {
        return taskTrackerStorage.getTaskTrackerFilePath();
    }

    @Override
    public Optional<ReadOnlyTaskTracker> readTaskTracker() throws DataConversionException, IOException {
        return readTaskTracker(taskTrackerStorage.getTaskTrackerFilePath());
    }

    @Override
    public Optional<ReadOnlyTaskTracker> readTaskTracker(String filePath) throws DataConversionException, IOException {
        logger.fine("Attempting to read data from file: " + filePath);
        return taskTrackerStorage.readTaskTracker(filePath);
    }

    @Override
    public void saveTaskTracker(ReadOnlyTaskTracker taskTracker) throws IOException {
        saveTaskTracker(taskTracker, taskTrackerStorage.getTaskTrackerFilePath());
    }

    @Override
    public void saveTaskTracker(ReadOnlyTaskTracker taskTracker, String filePath) throws IOException {
        logger.fine("Attempting to write to data file: " + filePath);
        taskTrackerStorage.saveTaskTracker(taskTracker, filePath);
    }


    @Override
    @Subscribe
    public void handleTaskTrackerChangedEvent(TaskTrackerChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event, "Local data changed, saving to file"));
        try {
            saveTaskTracker(event.data);
        } catch (IOException e) {
            raise(new DataSavingExceptionEvent(e));
        }
    }

}
```
###### \java\main\storage\TaskTrackerStorage.java
``` java
package main.storage;

import main.commons.exceptions.DataConversionException;
import main.model.ReadOnlyTaskTracker;

import java.io.IOException;
import java.util.Optional;

/**
 * Represents a storage for TaskTracker.
 */
public interface TaskTrackerStorage {

    /**
     * Returns the file path of the data file.
     */
    String getTaskTrackerFilePath();

    /**
     * Returns TaskTracker data as a ReadOnlyTaskTracker.
     *   Returns {@code Optional.empty()} if storage file is not found.
     * @throws DataConversionException if the data in storage is not in the expected format.
     * @throws IOException if there was any problem when reading from the storage.
     */
    Optional<ReadOnlyTaskTracker> readTaskTracker() throws DataConversionException, IOException;

    Optional<ReadOnlyTaskTracker> readTaskTracker(String filePath) throws DataConversionException, IOException;

    /**
     * Saves the given ReadOnlyTaskTracker to the storage.
     * @param taskTracker cannot be null.
     * @throws IOException if there was any problem writing to the file.
     */
    void saveTaskTracker(ReadOnlyTaskTracker taskTracker) throws IOException;
    
    void saveTaskTracker(ReadOnlyTaskTracker taskTracker, String filePath) throws IOException;

}
```
###### \java\main\storage\UserPrefsStorage.java
``` java
package main.storage;

import main.commons.exceptions.DataConversionException;
import main.model.UserPrefs;

import java.io.IOException;
import java.util.Optional;

/**
 * Represents a storage for UserPrefs.
 */
public interface UserPrefsStorage {

    /**
     * Returns UserPrefs data from storage.
     *   Returns {@code Optional.empty()} if storage file is not found.
     * @throws DataConversionException if the data in storage is not in the expected format.
     * @throws IOException if there was any problem when reading from the storage.
     */
    Optional<UserPrefs> readUserPrefs() throws DataConversionException, IOException;

    /**
     * Saves the given UserPrefs to the storage.
     * @param userPrefs cannot be null.
     * @throws IOException if there was any problem writing to the file.
     */
    void saveUserPrefs(UserPrefs userPrefs) throws IOException;
    
}
```
###### \java\main\storage\XmlAdaptedTask.java
``` java
package main.storage;

import main.commons.exceptions.IllegalValueException;
import main.model.task.*;

import javax.xml.bind.annotation.XmlElement;

import com.joestelmach.natty.generated.DateParser.date_return;

import java.util.Date;
import java.util.IllegalFormatCodePointException;
import java.util.ArrayList;
import java.util.List;

/**
 * JAXB-friendly version of the Task.
 */
public class XmlAdaptedTask {

    @XmlElement(required = true)
    private String message;
    @XmlElement(required = false)
    private Date deadline;
    @XmlElement(required = false)
    private Date startTime;
    @XmlElement(required = false)
    private Date endTime;
    @XmlElement(required = true)
    private boolean isRecurring;
    @XmlElement(required = true)
    private PriorityType priority;
    @XmlElement(required = true)
    private TaskType type;
    @XmlElement(required = true)
    private boolean isDone;
    @XmlElement(required = true)
    private boolean isInferred;
    
    
    /**
     * No-arg constructor for JAXB use.
     */ 
    public XmlAdaptedTask() {}


    /**
     * Converts a given Person into this class for JAXB use.
     *
     * @param source future changes to this will not affect the created XmlAdaptedTask
     */
    public XmlAdaptedTask(ReadOnlyTask source) {
        message = source.getMessage();
        deadline = (Date)(source.getDeadline());
        startTime = (Date)(source.getStartTime());
        endTime = (Date)(source.getEndTime());
        isRecurring = (Boolean)(source.getIsRecurring());
        priority = (PriorityType)(source.getPriority());
        type =(TaskType)(source.getType());
        isDone = (Boolean)(source.getIsDone());
        isInferred = (Boolean)(source.getIsInferred());
    }

    /**
     * Converts this jaxb-friendly adapted task object into the model's Task object.
     *
     * @throws IllegalValueException if there were any data constraints violated in the adapted task
     */
    public Task toModelType() throws IllegalValueException {
            
        if (type == TaskType.FLOATING) return new Task(message, priority);
        else if (type == TaskType.EVENT) return new Task(message, startTime, endTime, priority);
        else return new Task(message, deadline, priority);
        
    }
}
```
###### \java\main\storage\XmlFileStorage.java
``` java
package main.storage;

import main.commons.util.XmlUtil;
import main.commons.exceptions.DataConversionException;

import javax.xml.bind.JAXBException;
import java.io.File;
import java.io.FileNotFoundException;

/**
 * Stores tasktracker data in an XML file
 */
public class XmlFileStorage {
    /**
     * Saves the given tasktracker data to the specified file.
     */
    public static void saveDataToFile(File file, XmlSerializableTaskTracker taskTracker)
            throws FileNotFoundException {
        try {
            XmlUtil.saveDataToFile(file, taskTracker);
        } catch (JAXBException e) {
            assert false : "Unexpected exception " + e.getMessage();
        }
    }

    /**
     * Returns tasktracker in the file or an empty tasktracker
     */
    public static XmlSerializableTaskTracker loadDataFromSaveFile(File file) throws DataConversionException,
                                                                            FileNotFoundException {
        try {
            return XmlUtil.getDataFromFile(file, XmlSerializableTaskTracker.class);
        } catch (JAXBException e) {
            throw new DataConversionException(e);
        }
    }

}
```
###### \java\main\storage\XmlSerializableTaskTracker.java
``` java
package main.storage;

import main.commons.exceptions.IllegalValueException;
//import main.model.tag.Tag;
//import main.model.tag.UniqueTagList;
import main.model.ReadOnlyTaskTracker;
import main.model.task.ReadOnlyTask;
import main.model.task.UniqueTaskList;

import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

/**
 * An Immutable TaskTracker that is serializable to XML format
 */
@XmlRootElement(name = "tasktracker")
public class XmlSerializableTaskTracker implements ReadOnlyTaskTracker {

    @XmlElement
    private List<XmlAdaptedTask> tasks;
    {
        tasks = new ArrayList<>();
    }

    /**
     * Empty constructor required for marshalling
     */
    public XmlSerializableTaskTracker() {}

    /**
     * Conversion
     */
    public XmlSerializableTaskTracker(ReadOnlyTaskTracker src) {
        tasks.addAll(src.getTaskList().stream().map(XmlAdaptedTask::new).collect(Collectors.toList()));
    }

    @Override
    public UniqueTaskList getUniqueTaskList() {
        UniqueTaskList lists = new UniqueTaskList();
        for (XmlAdaptedTask t : tasks) {
            try {
                lists.add(t.toModelType());
            } catch (IllegalValueException e) {
            }
        }
        return lists;
    }

    @Override
    public List<ReadOnlyTask> getTaskList() {
        return tasks.stream().map(t -> {
            try {
                return t.toModelType();
            } catch (IllegalValueException e) {
                e.printStackTrace();
                return null;
            }
        }).collect(Collectors.toCollection(ArrayList::new));
    }

}
```
###### \java\main\storage\XmlTaskTrackerStorage.java
``` java
package main.storage;

import main.commons.core.LogsCenter;
import main.commons.exceptions.DataConversionException;
import main.commons.util.FileUtil;
import main.model.ReadOnlyTaskTracker;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.Optional;
import java.util.logging.Logger;

/**
 * A class to access TaskTracker data stored as an xml file on the hard disk.
 */
public class XmlTaskTrackerStorage implements TaskTrackerStorage {

    private static final Logger logger = LogsCenter.getLogger(XmlTaskTrackerStorage.class);

    private String filePath;

    public XmlTaskTrackerStorage(String filePath){
        this.filePath = filePath;
    }

    public String getTaskTrackerFilePath(){
        return filePath;
    }

    /**
     * Similar to readTaskTracker
     * @param filePath location of the data. Cannot be null
     * @throws DataConversionException if the file is not in the correct format.
     */
    public Optional<ReadOnlyTaskTracker> readTaskTracker(String filePath) throws DataConversionException, FileNotFoundException {
        assert filePath != null;

        File taskTrackerFile = new File(filePath);

        if (!taskTrackerFile.exists()) {
            logger.info("TaskTracker file "  + taskTrackerFile + " not found");
            return Optional.empty();
        }

        ReadOnlyTaskTracker taskTrackerOptional = XmlFileStorage.loadDataFromSaveFile(new File(filePath));

        return Optional.of(taskTrackerOptional);
    }

    /**
     * Similar to saveTaskTracker(ReadOnlyTaskTracker)
     * @param filePath location of the data. Cannot be null
     */
    public void saveTaskTracker(ReadOnlyTaskTracker taskTracker, String filePath) throws IOException {
        assert taskTracker != null;
        assert filePath != null;

        File file = new File(filePath);
        FileUtil.createIfMissing(file);
        XmlFileStorage.saveDataToFile(file, new XmlSerializableTaskTracker(taskTracker));
    }

    @Override
    public Optional<ReadOnlyTaskTracker> readTaskTracker() throws DataConversionException, IOException {
        return readTaskTracker(filePath);
    }

    @Override
    public void saveTaskTracker(ReadOnlyTaskTracker taskTracker) throws IOException {
        saveTaskTracker(taskTracker, filePath);
    }
}
```
